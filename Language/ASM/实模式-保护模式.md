### 什么是实模式
---
实模式（英语：Real mode）是Intel 80286和之后的x86兼容CPU的操作模式。**实模式的特性是一个20比特的区段存储器地址空间（意思为只有1MB的存储器可以被寻址），可以直接软件访问BIOS例程以及周边硬件，没有任何硬件等级的存储器保护观念或多任务。** 所有的80286系列和之后的x86 CPU都是以实模式下引导；80186和早期的CPU仅仅只有一种操作模式，也就是相当于后来芯片的这种实模式。

**286架构导入保护模式，允许硬件等级的存储器保护。** 然而要使用这些新的特性，需要额外先前不需要的软件指令。由于x86微处理机主要的设计规格，是能够完全地向前兼容于针对先前所有x86芯片所编写的软件，因此286芯片的引导是处于'实模式'—也就是关闭新的存储器保护特性的模式，所以可以执行针对旧的微处理器所设计的软件。到现在为止，即使最新的x86 CPU一开始在电源开启处于实模式下，也能够执行针对先前任何芯片所撰写的软件。
>x86CPU为了向后兼容性，以“实模式”启动 ——即启动时关闭内存保护（memory protection）特性，这样就可以运行为8086和8088编写的操作系统。截至2018年，当前的x86 CPU（包括x86-64 CPU）能够启动实模式操作系统，并且可以在不需要仿真或虚拟化（emulation or virtualization）的情况下运行几乎任何以前的x86编写的软件。

IBM引进的PC-BIOS与DOS操作系统（MS-DOS、DR-DOS等等）都是在实模式下运作。早期的Microsoft Windows版本（主要地只是图形用户界面外壳，而事实上不是操作系统）也在实模式下运行，直到Windows 3.0是第一种在保护模式下运行的Windows系列的操作系统。Windows 3.0进一步增强了这方面功能，能够在实模式或是保护模式下运行。Windows 3.0在保护模式下有两种运行"喜好" - "标准模式"，也就是使用保护模式来运行；而"386-增强模式"，允许使用32位寻址，因此无法在286上执行（尽管都有保护模式，但是286只是16位芯片；32位的寄存器在80386系列中推出）。**Windows 3.1不再允许在实模式下运行，只能在保护模式下运行，因此也是第一个最少需要80286处理器的主流作业环境（不管Windows/286，因为并非主流产品）。** 几乎所有的现今x86操作系统（Linux、Windows 95和之后、OS/2等等）都会在启动后将CPU切换到保护模式或长模式。

#### 实模式寻址方式
刚才说了8086CPU数据总线为16位，也就是一次最多能取2 ^ 16 = 64KB数据，这个数据也解释了实模式下为什么每个段最大只有64KB。但刚才还说了其地址总线为20位，这样它能寻址的能力其实是2 ^ 20 = 1MB，这也就是实模式下CPU的最大寻址能力既然。**它有1MB寻址能力，那怎么用16位的段寄存器表示呢？**

这就引出了分段的概念，8086CPU将1MB存储空间分成许多逻辑段，每个段最大限长为64KB（但不一定就是64KB）。这样每个存储单元就可以用“段基地址+段内偏移地址”表示**段基地址由16位段寄存器值左移4位表达，段内偏移表示相对于某个段起始位置的偏移量比如。**
```
SEG = 0x07c0
jmpi offset，＃SEG
offset：mov ax，cs 
```

#### 保护模式寻址方式
随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，**实现更大空间的，更灵活也更安全的内存访问。**

在定义“逻辑地址”时看到**保护模式和实模式的区别在于它是用段选择符而非段基地址**，这也许就是保护模式的真谛所在，从段选择符入手，全面理解保护模式编程基本概念和寻址方式。

- 分段机制
- 分页机制
##### 分段机制
💡最开始分段的主要原因就是因为 8086 地址线和数据线不匹配导致的。
逻辑地址的前 ... 位是段选择符， 后...位是偏移地址

GDT 全局描述符表， LDT局部描述符表(windows并没有使用它)

`GDT表`存在于内存之中。`CPU`要想找到它，就必须知道它的位置。于是乎`CPU`有一个寄存器。它被称之为`GDTR`，存储了GDT表的位置和大小，是一个48位的寄存器

按Intel的规定，每个进程有一个任务状态段（TSS）和局部描述符表LDT，但Linux也没有完全遵循Intel的设计思路。如前所述，Linux的进程没有使用LDT，而对TSS的使用也非常有限，每个CPU仅使用一个TSS。

从2.2版开始，Linux让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。但内核中也用到LDT，那只是在VM86模式中运行Wine，因为就是说在Linux上模拟运行Winodws软件或DOS软件的程序时才使用。

###### 段选择子
段选择子结构简单，它是一个16位的描述符，指向了定义该段的段描述符。
![[段选择子.png]]
- RPL：请求特权级别，通俗的讲我用什么权限来请求。
- TI：TI=0时，查GDT表；TI=1时，查LDT表。
- Index：处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的段描述符。

###### 段选择符
![[段描述符.png]]

- BASE: 段基址，由上图中的两部分(BASE 31-24 和 BASE 23-16)组成
- G：LIMIT的单位，该位 0表示单位是字节，1表示单位是 4KB
- D/B: 该位为 0 表示这是一个 16 位的段，1 表示这是一个 32 位段
- AVL: 该位是用户位，可以被用户自由使用
- LIMIT: 段的界限，单位由 G 位决定。数值上（经过单位换算后的值）等于段的长度（字节）- 1
- P: 段存在位，该位为 0 表示该段不存在，为 1 表示存在
- DPL：段权限
- S: 该位为 1 表示这是一个数据段或者代码段。为 0 表示这是一个系统段（比如调用门，中断门等）
- TYPE: 根据 S 位的结果，再次对段类型进行细分


**段选择符**从描述符表中选择**段描述符**

一个多段模型充分发挥了段机制的对代码，数据结构和程序提供硬件保护的能力。**每个程序都有自己的段描述符表和自己的段**。段可以完全属于程序私有也可以和其它程序之间共享。

访问权限的检查不仅仅用来保护地址越界，也可以保护某一特定段不允许操作。例如代码段是只读段，硬件可以阻击向代码段进行写操作。
![[segment.png]]

### 长模式
在x86-64处理器架构中，当处于长模式（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。虚拟86模式在长模式下不可用，也就是说，长模式不兼容16位程序。

### 三种地址
---
逻辑地址：即逻辑上的地址，实模式下由“段基地址+段内偏移”组成;保护模式下由“段选择符+段内偏移”组成。

线性地址：逻辑地址经分段机制后就成线性地址，它是平坦的;如果不启用分页，那么此线性地址即物理地址。

物理地址：线性地址经分页转换后就成了物理地址。

