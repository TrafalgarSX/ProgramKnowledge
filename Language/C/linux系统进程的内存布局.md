### 进程内存（虚拟内存）
内存管理模块是操作系统的心脏；它对应用程序和系统管理非常重要。

由于不少概念是通用的，所以文中大部分例子取自32位x86平台的Linux和Windows系统。

在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。

**这个沙盘就是虚拟地址空间（virtual address space）**，在32位模式下它总是一个4GB的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。

#### Kernel Space
每一个进程拥有一套属于它自己的页表，但是还有一个隐情。**只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身。因此一部分虚拟地址必须保留给内核使用：**

内核空间由操作系统内核使用, 不会随进程变化而切换。
内核空间由内核**根据独立且唯一的页表init_mm.pgd 进行映射**，而用户空间的页表则每个进程一份。

![[系统进程的内存布局.png]]

这并不意味着内核使用了那么多的物理内存，仅表示它可支配这么大的地址空间，可根据内核需要，将其映射到物理内存。

内核空间在页表中拥有较高的特权级（ring 2或以下），因此**只要用户态的程序试图访问这些页，就会导致一个页错误（page fault）**。

在Linux中，内核空间是持续存在的，并且**在所有进程中都映射到同样的物理内存**。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化：


**为什么要区分内核空间和用户空间？**  

大致有三点因素：

第一点：操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的；

第二点：分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性，并且管理上很方便；

第三点：也是重要的一点，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。

![[user_kernel.png]]

简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。

Kernel space 可以执行任意命令，调用系统的一切资源；

相对来说，User space 执行的是较为简单的运算，执行的运算不影响其他程序的执行，并且不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。


❓总是可寻址 的是什么意思？
![[不同进程的内存分布.png]]

蓝色区域表示映射到物理内存的虚拟地址。
白色区域表示未映射的部分。

在上面的例子中，Firefox使用了相当多的虚拟地址空间，因为它是传说中的吃内存大户。地址空间中的各个条带对应于不同的内存段（memory segment），如：堆、栈之类的。记住，这些段只是简单的内存地址范围，与Intel处理器的段没有关系。不管怎样，下面是一个Linux进程的标准的内存段布局：

![[内存段布局.png]]

当计算机开心、安全、可爱、正常的运转时，几乎每一个进程的各个段的起始虚拟地址都与上图完全一致，这也给远程发掘程序安全漏洞打开了方便之门。

一个发掘过程往往需要引用绝对内存地址：栈地址，库函数地址等。远程攻击者必须依赖地址空间布局的一致性，摸索着选择这些地址。如果让他们猜个正着，有人就会被整了。因此，地址空间的随机排布方式逐渐流行起来。Linux 通过对[栈](http://lxr.linux.no/linux+v2.6.28.1/fs/binfmt_elf.c#L542)[内存映射段](http://lxr.linux.no/linux+v2.6.28.1/arch/x86/mm/mmap.c#L84)、[堆](http://lxr.linux.no/linux+v2.6.28.1/arch/x86/kernel/process_32.c#L729)的起始地址加上随机的偏移量来打乱布局。不幸的是，32 位地址空间相当紧凑，给随机化所留下的空当不大，[削弱了这种技巧的效果](http://www.stanford.edu/~blp/papers/asrandom.pdf)。

进程地址空间中最顶部的段是栈，大多数编程语言将之用于**存储局部变量和函数参数**。

调用一个方法或函数会将一个新的栈桢（stack frame）压入栈中。栈桢在函数返回时被清理。也许是因为数据严格的遵从[LIFO](http://en.wikipedia.org/wiki/Lifo)的顺序，**这个简单的设计意味着不必使用复杂的数据结构来追踪栈的内容，只需要一个简单的指针指向栈的顶端即可**。因此压栈（pushing）和退栈（popping）过程非常迅速、准确。另外，持续的重用栈空间有助于使活跃的栈内存保持在[CPU缓存中](http://blog.csdn.net/drshenlei/archive/2009/06/17/4277959.aspx)，从而加速访问。进程中的每一个线程都有属于自己的栈。

通过不断向栈中压入的数据，超出其容量就有会耗尽栈所对应的内存区域。**这将触发一个页故障（page fault）**，并被 Linux 的[expand_stack()](http://lxr.linux.no/linux+v2.6.28/mm/mmap.c#L1716)处理，它会调用[acct_stack_growth()](http://lxr.linux.no/linux+v2.6.28/mm/mmap.c#L1544)来检查是否还有合适的地方用于栈的增长。**如果栈的大小低于RLIMIT_STACK（通常是8MB）**，那么一般情况下栈会被加长，程序继续愉快的运行，感觉不到发生了什么事情。这是一种将栈扩展至所需大小的常规机制。然而，**如果达到了最大的栈空间大小，就会栈溢出（stack overflow）**，程序收到一个段错误（Segmentation Fault）。当映射了的栈区域扩展到所需的大小后，它就不会再收缩回去，即使栈不那么满了。这就好比联邦预算，它总是在增长的。

❗**动态栈增长是唯一一种访问未映射内存区域（图中白色区域）而被允许的情形**。其它任何对未映射内存区域的访问都会触发页故障，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。

#### mmap 加载动态库  创建匿名内存映射
在栈的下方，是我们的内存映射段。此处，内核将文件的内容直接映射到内存。任何应用程序都可以通过 Linux 的 [mmap()](http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html) 系统调用（[实现](http://lxr.linux.no/linux+v2.6.28.1/arch/x86/kernel/sys_i386_32.c#L27)）或 Windows 的 [CreateFileMapping()](http://msdn.microsoft.com/en-us/library/aa366537%28VS.85%29.aspx)/[MapViewOfFile()](http://msdn.microsoft.com/en-us/library/aa366761%28VS.85%29.aspx)请求这种映射。内存映射是一种方便高效的文件 I/O 方式，所以它被用于加载动态库。创建一个不对应于任何文件的匿名内存映射也是可能的，此方法用于存放程序的数据。在 Linux 中，如果你通过 [malloc()](http://www.kernel.org/doc/man-pages/online/pages/man3/malloc.3.html)请求一大块内存，C 运行库将会创建这样一个匿名映射而不是使用堆内存。‘大块’意味着比MMAP_THRESHOLD 还大，缺省是 128KB ，可以通过[mallopt()](http://www.kernel.org/doc/man-pages/online/pages/man3/undocumented.3.html)调整。

#### 堆
如果堆中有足够的空间来满足内存请求，它就可以被语言运行时库处理而不需要内核参与。**否则，堆会被扩大，通过[brk()](http://www.kernel.org/doc/man-pages/online/pages/man2/brk.2.html)系统调用（[实现](http://lxr.linux.no/linux+v2.6.28.1/mm/mmap.c#L248)）来分配请求所需的内存块**。堆管理是很[复杂](http://g.oswego.edu/dl/html/malloc.html)的，需要精细的算法，应付我们程序中杂乱的分配模式，优化速度和内存使用效率。处理一个堆请求所需的时间会大幅度的变动。实时系统通过[特殊目的分配器](http://rtportal.upv.es/rtmalloc/)来解决这个问题。堆也可能会变得零零碎碎，如下图所示：

#### BSS data
最后，我们来看看最底部的内存段：BSS，数据段，代码段。

在C语言中，BSS和data保存的都是静态（全局）变量的内容。

❗区别在于**BSS保存的是未被初始化的静态变量内容**，它们的值不是直接在程序的源代码中设定的。**BSS内存区域是匿名的：它不映射到任何文件**。如果你写static int cntActiveUsers，则cntActiveUsers的内容就会保存在BSS中。

data保存在源代码中已经初始化了的静态变量内容。**这个内存区域不是匿名的。它映射了一部分的程序二进制镜像**，也就是源代码中指定了初始值的静态变量。所以，如果你写static int cntWorkerBees = 10，则cntWorkerBees的内容就保存在数据段中了，而且初始值为10。**尽管数据段映射了一个文件，但它是一个私有内存映射，这意味着更改此处的内存不会影响到被映射的文件**。也必须如此，否则给全局变量赋值将会改动你硬盘上的二进制镜像，这是不可想象的。

下图中数据段的例子更加详细，它有一个指针。在此情况下，**指针gonzo（4字节内存地址）本身的值保存在data段中**。而**它所指向的实际字符串则不在这里。这个字符串保存在代码段中**。

**代码段是只读的，保存了你全部的代码外加零零碎碎的东西，比如字符串字面值**。代码段将你的二进制文件也映射到了内存中，但对此区域的写操作都会使你的程序收到段错误。这有助于防范指针错误，虽然不像在C语言编程时就注意防范来得那么有效。下图展示了这些段以及我们例子中的变量：

![[BSS-Data-Text详情.png]]

💡你可以通过阅读文件/proc/pid_of_process/maps来**检验一个Linux进程中的内存区域。**

记住一个段可能包含许多区域。比如，**每个内存映射文件在mmap段中都有属于自己的区域，动态库拥有类似BSS和data段的额外区域**。下一篇文章讲说明这些“区域”（area）的真正含义。有时人们提到“数据段”，指的就是全部的数据段 + BSS + 堆。

💡你可以通过[nm](http://manpages.ubuntu.com/manpages/intrepid/en/man1/nm.1.html)和[objdump](http://manpages.ubuntu.com/manpages/intrepid/en/man1/objdump.1.html)命令来察看二进制文件，**打印其中的符号，它们的地址，段等信息**。最后需要指出的是，前文描述的虚拟地址布局在Linux 中是一种“灵活布局”（flexible layout），而且以此作为默认方式已经有些年头了。它假设我们有值 RLIMIT_STACK。当情况不是这样时， Linux 退回使用“经典布局”（classic layout），如下图所示：

![[linux_classic_layout.png]]


### 参考
[Linux进程的内存空间布局 - Backend-Development](https://mqjyl2012.gitbook.io/backend-development/operating-system/linux-basics/linux-process-memory-space-layout)
### nm命令

有时候可能需要查看一个库中到底有哪些函数，**nm**命令可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：

-  一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；

-  一种是库中定义的函数，用T表示，这是最常见的；

-  一种是所谓的弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。

```bash
$nm libhello.h
```

### ldd命令

**ldd**命令可以查看一个可执行程序依赖的共享库，例如我们编写的四则运算动态库依赖下面这些库：


对任何一个普通C++程序来讲，它都会涉及到5种不同的数据段。常用的几个数据段种包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。

1. 代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存种的镜像。**代码段需要防止在运行时被非法修改，所以只准许读取操作**，而不允许写入（修改）操作——它是不可写的。

2. 数据段：**数据段用来存放可执行文件中已初始化全局变量**，换句话说就是存放程序静态分配的变量和全局变量。

3. BSS段：**BSS段包含了程序中未初始化全局变量**，在内存中bss段全部置零。

4. 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或缩减。当进程调用malloc/new等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

5. 栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（**但不包括static声明的变量，static意味这在数据段中存放变量**）。除此以外在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上将我们可以把堆栈看成一个临时数据寄存、交换的内存区。