### 字节对齐的原因和作用
---
不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能**从特定地址开始存取**，而不允许其在内存中任意存放。

但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来**存取效率**上的损失。

合理利用字节对齐还可以有效地节省存储空间。

### 结构体对齐
---
```c
struct A{
    int    a;
    char   b;
    short  c;
};
struct B{
    char   b;
    int    a;
    short  c;
};

  printf("%d\n", sizeof(struct A));   // 8

  printf("%d\n", sizeof(struct B));   // 12
```
和自己计算出来的结果不一样， 成员顺序改变后， 结构体的大小又发生了变化。

#### 对齐准则
一定要搞清楚：
1. 自身对齐值
2. 指定对齐值
3. 有效对齐值

先看4个重要的基本概念
1. 数据类型自身的对齐值（自身的大小)
2. 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值
3. 指定对齐值： `#pragmaticpack(value)`   的value
4. 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，i.e. **有效对齐值=min{自身对齐值， 当前指定的pack值}**
基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。

👉有效对齐值N是最终用来决定数据存放地址方式的值。**有效对齐N表示“对齐在N上”，即该数据的“存放起始地址 mod N=0”。** 而数据结构中的数据变量都是按定义的先后顺序存放。**第一个数据变量的起始地址就是数据结构的起始地址**。结构体的**成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整**

💡即结构体成员变量占用**总长度**为结构体**有效对齐值**的整数倍。

##### 总结
结构体字节对齐的细节和具体编译器的实现相关， 但一般而言满足三个准则：
1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。（被结构体的自身对齐值整除）
2. 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的正数倍，如有需要编译器会在成员之间加上填充字节。
3. 结构他的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上你填充字节(trailing padding)

下面的规则里似乎并不考虑**指定对齐值**的影响。

#### 更改对齐方式
在缺省情况下，C编译器为每一个变量或是数据单元按其自然对界条件分配空间。一般地，可以通过下面的方法来改变缺省的对界条件：

- 使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；
- 使用伪指令#pragma pack()： 取消自定义字节对齐方式。

另外，还有如下的一种方式(GCC特有语法)：
1. `__attribute((aligned (n)))`： 让所作用的结构成员对齐在n字节自然边界上。如果结构体中有成员的长度大于n，则按照最大成员的长度来对齐。
2. `__attribute__ ((packed))`： 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。

#### 不同架构处理器的对齐要求
**RISC指令集处理器(MIPS/ARM)**：这种处理器的设计以效率为先，要求所访问的多字节数据(short/int/ long)的地址必须是为此数据大小的倍数，如short数据地址应为2的倍数，long数据地址应为4的倍数，也就是说是对齐的。

**CISC指令集处理器(X86)**：没有上述限制。

##### 对齐处理策略
访问非对齐多字节数据时(pack数据)，编译器会将指令拆成多条(因为非对齐多字节数据可能跨越地址对齐边界)，保证每条指令都从正确的起始地址上获取数据，但也因此效率比较低。

访问对齐数据时则只用一条指令获取数据，因此对齐数据必须确保其起始地址是在对齐边界上。如果不是在对齐的边界，对X86 CPU是安全的，但对MIPS/ARM这种RISC CPU会出现“总线访问异常”。

**为什么X86是安全的呢？**

X86 CPU是如何进行数据对齐的。**X86  CPU的EFLAGS寄存器中包含一个特殊的位标志，称为AC(对齐检查的英文缩写)标志**。按照默认设置，当CPU首次加电时，该标志被设置为0。当该标志是0时，CPU能够自动执行它应该执行的操作，以便成功地访问未对齐的数据值。然而，如果该标志被设置为1，每当系统试图访问未对齐的数据时，CPU就会发出一个INT 17H中断。X86的Windows 2000和Windows   98版本从来不改变这个CPU标志位。因此，当应用程序在X86处理器上运行时，你根本看不到应用程序中出现数据未对齐的异常条件。

**为什么MIPS/ARM不安全呢？**

因为MIPS/ARM  CPU不能自动处理对未对齐数据的访问。当未对齐的数据访问发生时，CPU就会将这一情况通知操作系统。这时，操作系统将会确定它是否应该引发一个数据未对齐异常条件，对vxworks是会触发这个异常的。