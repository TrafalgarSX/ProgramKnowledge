### GDB调试原理
---
在使用gcc编译时，可以使用-g选项在可执行文件中嵌入更多的调试信息。那么：

- 具体嵌入了哪些调试信息？
- 这些调试信息如何与二进制的指令之间进行相互交互？
- 在调试的时候，调试信息中是如何获取函数调用栈中的上下文信息的？

1. 本地调试， 调试程序和被调试程序在同一台电脑中：
可视化调试程序   <-->   GDB   <-->   目标程序
2. 远程调试： 被调试程序在另一台电脑中：
可视化调试程序   <-->   GDB   <-->  GDBServer   <-->  目标程序
>远程调试GdbServer和目标程序都是运行在目标机上
>GDB与GdbServer通讯是通过**RSP协议**： GDB Remote Serial Protocol(GDB远程通信协议)

#### GDB与被调试程序之间的关系
---
系统首先会启动GDB进程， 这个进程会调用系统函数fork()来创建一个**子进程**， 这个子进程做两件事情：
1. 调用系统函数ptrace(PTRACE_TRACEME, [args]);
2. 通过execc来加载， 执行可执行程序test, 那么test程序就在这个子进程中开始执行

💡“程序”描述的是一个静态的概念，就是在硬盘上的一堆数据，而“进程”描述的是动态的概念， 是这个程序被读取，加载到内存上之后， 在操作系统中有一个任务控制块， 专门用来管理这个进程的。

👉gdb拥有强大的调试能力， 就是因为系统调用函数`ptrace`

`tracer`  是调试程序，可以理解为gdb程序； `tracee`就是被调试程序，对应于目标程序

>ptrace系统函数是Linux内核提供的一个用于**进程跟踪的系统调用**， 通过它，一个进程(gdb)可以读写另外一个**进程(test)的指令空间、数据空间、堆栈和寄存器的值**。
>
>而且**gdb进程接管了test进程的所有信号**，也就是说系统向test进程发送的所有信号，都被gdb进程接收到，这样一来，test进程的执行就被gdb控制了， 从而达到调试的目的

如果使用 gdb 来调试程序， 那么操作系统发送给目标进程的信号就会被 gdb 截获， gdb根据信号的属性来决定信号转交给目标程序，如此一来，目标程序就在gdb发来的信号指挥下进行相应的动作。 

#### GDB如何调试已经执行的服务进程
---
- 主动调试是子进程调用 ptrace(PTRACE_TRACEME,...), 相当于子进程对操作系统说：gdb进程是我的父进程，以后任何想发给“我” 的信号，都直接发给 父进程 gdb
- 对已经执行的进程进行调试，是在gdb这个父进程中调用 ptrace(PTRACE_ATTACH,...)，此时gdb进程会attach到已经执行的进程

gdb会把已经执行的进程 “收养” 为自己的子进程， 此时 gdb 进程会发送SIGSTO信号给子进程， 子进程接收到SIGSTO信号后，就会暂停执行进入TASK_STOPED状态，标识自己准备好被调试了

⚠️关于绑定，有几个限制：不允许自我绑定， 不允许多次绑定到同一个进程，不允许绑定 1 号进程

#### GDB如何实现断点指令
---
1. 在某一行设置断点， gdb做了两件事
   1. 将断点处的源码所对应的汇编代码存储到断点链表中。
   2. 在断点处汇编代码的开始， 插入终端指令INT3
2. 然后在调试窗口输入执行指令 `run`，直到遇到断点暂停，汇编代码中的PC指针发现断点处的INT3指令，操作系统就向正在调试的进程发送一个SIGTRAP信号。
3. 断点处的汇编代码（此时被替换了INT3）被执行过后， PC = PC + 1，就指向下一行了
4. 操作系统发给被调试进程的任何信号都被gdb接管， gdb 接收到 SIGTRAP信号后， gdb 发现根据当前汇编代码执行的位置到断点链表中查找 断点位置原来的代码（被INT3替换的汇编代码），紧接着做了两个操作：
   1. 把汇编代码中的INT3替换回来原来的代码（原来的汇编代码保存在断点链表中）
   2. 把PC指针回退一步， 也就是设置指向断点的位置
5. 最后 gdb 继续等待用户的调试指令，此时相当于下一条执行的指令是汇编代码中设置断点的位置，此时我们可以继续输入其他调试指令来debug, 比如：查看变量值，查看堆栈信息，修改局部变量的值等。

#### GDB如何实现单步指令next
---
在调试窗口输入单步执行的指令next, 执行一样源代码（比如一行C的代码），gdb会计算出这一行源码对应的汇编代码执行到哪里，然后gdb就控制汇编代码中的PC一直性质， 知道相对应计算出来的汇编代码执行结束，就停止下来，然后继续等待用户输入调试指令。
