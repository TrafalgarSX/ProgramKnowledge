### 头文件作用
在预处理阶段，编译器将源文件包含的头文件内容复制到包含语句(#include)处。在源文件编译时，连同被包含进来的头文件内容一起编译，生成目标文件（.obj)。

如果所包含的头文件非常庞大，则会严重降低编译速度(使用GCC的-E选项可获得并查看最终预处理完的文件)。

因此，在源文件中应仅包含必需的头文件，且尽量不要在头文件中包含其他头文件。

下面两条命令可以查看 g++ 和 clang++的 include查找路径
```
g++ -E -x c++ - -v < /dev/null 
clang++ -E -x c++ - -v < /dev/null
```

![[C++常识#what is the difference between ` include <filename>` and ` include "filename"`?]]

### 头文件组织原则
源文件中实现变量、函数的定义，**并指定链接范围**。头文件中书写外部需要使用的全局变量、函数声明及数据类型和宏的定义。
1. 头文件划分原则： 类型定义、宏定义尽量与函数声明相分离，分别位于不同的头文件中。内部函数声明头文件与外部函数声明头文件相分离，内部类型定义头文件与外部类型定义头文件相分离。（什么是内部函数声明，外部函数声明？）
2. 不同层次的函数声明不要放在一个头文件中
3. 头文件中不应该包含本地数据，以降低模块间耦合度
i.e.只有源文件自己使用的类型、宏定义和变量、函数声明，不应出现在头文件里。作用域限于单文件的私有变量和函数应该声明为static,以防外部调用。
4. 头文件内不允许定义变量和函数，只能有宏、类型（typedef/struct/union/enum等）及变量和函数的声明。特殊情况下可extern基本类型的全局变量，源文件通过包含该头文件访问全局变量。
5. 说明性头文件不需要有对应的源文件。此类头文件内大多包含大量概念性宏定义或枚举类型定义，不包含任何其他类型定义和变量或函数声明。此类头文件也不应该包含其他头文件。
6. 使用#progma once 或 header guard 避免头文件重复包含。#progma once 是一种非标准但已被现代编译器广泛支持的技巧（更快，更简单，但只能针对文件，无法针对代码块）。

### 头文件包含原则
头文件包含不当会引发编译时报告符号未定义的错误或重复定义的警告。

要消除符号未定义的编译错误，只需要在引用符号（变量、函数、数据类型及宏等）前确保它已被声明或定义。

要消除重复定义的警告，则需要合理设计头文件包含顺序及层次
1. 源文件内的头文件包含顺序应从最特殊到一般，e.g.
```c
#include"通用头文件" //可能定义本模块数据类型别名
#include"源文件同名头文件"
#include"本模块其他头文件"
#include"自定义工具头文件"
#include"第三方头文件"
#include"平台相关头文件"
#include<C++库头文件>
#include<C库头文件>
```

2. 减少头文件的嵌套和交叉引。e.g.
头文件A中出现的类型定义在头文件B中，则头文件A应包含头文件B，除此以外的其他头文件不允许包含。
3. **头文件应包含哪些头文件仅取决于自身，而非包含该头文件的源文件**  我的习惯是错误的
e.g. 编译源文件时需要用到的头文件B,且源文件已包含头文件A,索性将头文件B包含在头文件A中，这是错误的做法。
4. 头文件应该是自完备的，即在任一源文件中包含任一头文件而不会产生编译错误。
5. 源文件中包含的头文件尽量不要有依赖顺序
6. 尽量在源文件中包含头文件，而非在头文件中。且源文件仅包好所需的头文件。**我的习惯是错误的**
7. 对于函数库（包含标准库和自定义的公共宏及接口）的头文件，可将其加入到一个通用头文件中。需要控制该头文件的体积，并确保所有源文件**首先包含**该通用头文件。e.g.
```c
 #ifndef  _OMCI_COMMON_H
 #define  _OMCI_COMMON_H
/*******************************************************************************************
 * 说明:
 * 本文件仅应包含与具体通信协议无关的通用数据类型及宏定义。
 * 为简化头文件包含且不失可移植性，本文件内可包含少量C库通用头文件。
 * 因本文件内定义基本数据类型别名，故.c文件中应将本头文件置于包含列表顶端，
 * 否则编译时可能产生类型未定义错误。
 *******************************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/time.h>
 #include <limits.h>
 
 #include "Omci_Byte.h"

```

👍一个很有意思的技巧：
8. 避免包含重量级的平台头文件，如windows.h等。若仅使用头文件少量函数，可extern函数到源文件内。如下：
```
 /**********************************************************************************************
 外部函数声明 (当外部接口未提供头文件或头文件过于复杂时) 
 **********************************************************************************************/
 //因声明所在头文件引用混乱，此处仅extern函数声明。
 extern INT32S DBShmCliInit(VOID); //#include "db_shm_mgr.h"
 extern INT32S cmLockInit(VOID);   //#include "common_cmapi.h"
```
若还使用该头文件的某些类型和宏定义，可创建**适配性源文件**。在该源文件内包含平台头文件，封装新的接口并将其声明在同名头文件内，其他源文件将通过适配头文件简介访问平台接口。
```c
/*****************************************************************************************
* 文件名称： Omci_Send_Msg.c
* 内容摘要： OMCI消息转发接口
* 其它说明： 该头文件封装SEND接口，以避免其他源文件包含支撑api和pid公共头文件导致引用混乱。
 *****************************************************************************************/
#include "Omci_Common.h"
#include "Omci_Send_Msg.h"
#include "oss_api.h"
/**********************************************************************************************
                                         函数实现区
**********************************************************************************************/

//向自身进程发送异步消息
INT32U OmciAsynSendSelf(INT16U wEvent, VOID *pvMsg, INT16U wMsgLen)
{
    PID dwSelfPid = 0;
    SELF(&dwSelfPid);
    return ASEND(wEvent, pvMsg, wMsgLen, dwSelfPid);
}
```

9. 头文件若能前置声明，就不要包含另一头文件。仅当前置声明不能满足或过于麻烦时采用include,如此可以减少依赖性方面的问题。e.g.
```c
struct T_MeInfoMap;  //前置声明
struct T_OmciMsg;    //前置声明

typedef FUNC_STATUS (*OmciChkFunc)(struct T_MeInfoMap *ptMeInfo, struct T_OmciMsg *ptMsg, struct T_OmciMsg *ptAckMsg);


//OMCI实体信息
typedef struct{
    INT16U wMeClass;               //实体类别
    OMCI_ATTR_INFO *pMeAttrInfo;   //实体所定义的属性信息指针
    INT8U  ucAttrNum;              //实体所定义的属性数目
    INT16U wTotalAttrLen;          //实体所有属性所占的总字节数，初始化为0，动态计算
    INT8U  *pszDbName;             //实体存库时的数据表名称，建议不要超过DB_NAME_LEN(32)
    INT16U wMaxRecNum;             //实体存库时支持的最大记录数目
    OmciChkFunc fnCheck;           //Omci校验函数指针
    BOOL   bDbCreated;             //实体数据表是否已创建
}OMCI_ME_INFO_MAP;
```


### 代码文件组织原则
1. 使用层次化和模块化的软件开发模型。每个模块只能使用所在层和下一层模块提供的接口。 现在的项目就是这样开发的
2. 每个模块的文件(可能多个)保存在一个独立文件夹中。
模块文件较多时可采用子目录的方式，物理上隔离不同层次的文件。子目录下源文件和头文件应分开存放，如分别置入include和source目录。
3. 用于**模块裁减的条件编译宏**保存在一个独立文件中，便于软件裁减。
4. 硬件相关代码和操作系统相关代码与工程代码相对独立保存，以便于软件移植。
5. 声明和定义分开，使用头文件暴露模块需要提供给外部的类型、宏、变量和函数。

### 全局变量使用原则
1. 若全局变量尽在单个源文件中访问，则可将该变量改为该文件内的静态全局变量。
2. 若全局变量仅在单个函数内访问，则可将该变量改为该函数内的静态局部变量。
3. 尽量不要使用extern声明全局变量，最好提供函数访问这些变量。直接暴露全局变量不安全。
4. 设计和调用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题。

⚠️C语言中不支持extern "C"声明，在.c文件中包含extern "C"时会出现编译语法错误。


### 声明和定义
 全局变量或函数可(在多个编译单元中)有多处声明，但只允许定义一次。
 
 全局变量定义时分配空间并赋初始值(如果有)；函数定义时提供函数体内容。
```
声明：

extern int iGlobal;

extern int func(); 或int func();

定义：

int iGlobal = 0; 或int iGlobal;

int func (){

    return 1;}
```

   在多个源文件中共享变量或函数时，需确保定义和声明的一致性。通常在某个相关的源文件中定义，然后在头文件中进行外部声明。需要使用时包含相应的头文件即可。定义变量的源文件也应包含该头文件，以便编译器检查定义和声明的一致性。

Unix编译器和链接器常使用允许多重定义的“通用模式”，只要保证最多对一处定义进行初始化即可。该方式被ANSI C标准称为一种“通用扩展”)。

通用扩展在《深入理解计算机系统》中解释为：多重定义的符号只允许最多一个强符号。函数和定义时已初始化的全局变量是强符号；未初始化的全局变量是弱符号。Unix链接器使用以下规则来处理多重定义的符号：

     规则一：不允许有多个强符号。在被多个源文件包含的头文件内定义的全局变量会被定义多次(预处理阶段会将头文件内容展开在源文件中)，若在定义时显式地赋值(初始化)，则会违反此规则。

     规则二：若存在一个强符号和多个弱符号，则选择强符号。

     规则三：若存在多个弱符号，则从这些弱符号中任选一个。

因此，应尽量避免使用全局变量。若确有必要，应采用静态全局变量(无强弱之分，且不会和其他全局符号产生冲突)，并封装访问函数供外部文件调用。

### 前向声明
结构体类型S在声明之后定义之前是一个不完全类型(incomplete type)，即已知S是一个类型，但不知道包含哪些成员。不完全类型只能用于定义指向该类型的指针，或声明使用该类型作为形参指针类型或返回指针类型的函数。指针类型对编译器而言大小固定(如32位机上为四字节)，不会出现编译错误。
```c
 typedef struct DefStruct_t DefStruct;
 typedef BOOL (*func)(const DefStruct *ptStrt);
 
 struct DefStruct_t{
     int i;
     func f;
 };

Correct Code
```

 ⚠️注意，**在前向声明和具体定义之间涉及标识符(变量、结构、函数等)实现细节的使用都是非法的。** 若函数被前向声明但未被调用，则编译和运行正常；若前向声明函数被调用但未被定义，则编译正常但链接报错(undefined reference)。将具体定义放在源文件中可部分避免该问题。
### 参考
[C语言头文件组织与包含原则 - clover\_toeic - 博客园](https://www.cnblogs.com/clover-toeic/p/3728026.html)
[c++ - What is the difference between #include \<filename\> and #include "filename"? - Stack Overflow](https://stackoverflow.com/questions/21593/what-is-the-difference-between-include-filename-and-include-filename)
[Where does GCC look to find its header files?](https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art026)
[#include directive (C/C++) | Microsoft Learn](https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=msvc-170&viewFallbackFrom=vs-2019)