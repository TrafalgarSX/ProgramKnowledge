### UB行为导致了不太容易推断的错误
```c
#include <stdio.h>
#include <string.h>
int main(int argc, char const *argv[]) {
    char *p = "abcde";
    char m, n, x, y;
    m = *p;
    n = *(p++);
    x = *p++;
    y = ++(*p);
    printf("%c,%c,%c,%c", m, n, x, y);
    return 0;
}

```
这里面有两个错误：
1. 出现了段错误。
2. 输出行为不符合预期
```
预期：  a b b c
实际：  a a b 段错误
前者预期为 b 是认为应该先算括号中内容
```
#### UB行为
```
前缀自增，则先自增，后使用；
后缀自增，先使用，后自增。
```

实际上后缀自增不是简单的先使用后自增。
**执行一个后自增运算会产生一个`副效应`,这个副效应会让值自增，但是C语言规定，副效应会`在下个序列点或在那之前完成`。**

虽然赋值运算确实存在一个序列点，但是又存在另一条规则：
```
直接赋值运算符与所有复合赋值运算符的副效应（修改左参数）后序于左右参数的值计算（但非其副效应）。 比如 后自增运算的副效应。
```
也就是说，虽然赋值操作存在序列点，但是该序列点并不后序于 右值运算的副效应。

也就是说 如果赋值序列点之前没有其他序列点，右值运算的副效应实在赋值序列点之前的
如果有其他序列点，则右值运算的副效应在其他序列点之前完成。

```text
若一个标量对象上的副效应与另一个使用同一标量对象之值的值计算相对无顺序，则行为未定义。
```

即，对于 `n = *(p++)` 这个表达式而言，括号结束就自增是合理的，整个赋值语句结束之后才自增是合理的

#### 段错误
多数时候通常认为段错误就是数组越界。

实际上的段错误：
段错误指，**当程序访问了它不能访问的内存空间，保护模式下的CPU会捕捉到，并保护这段内存空间，操作系统会捕捉到这段异常，并发送信号让程序终止，并抛出段错误异常。

eg: 程序访问了本就不存在的内存，或访问的内存并非属于这个程序，或访问的内存不可读或不可写（eg 向只读内存空间写入数据触发内存保护）。

⚠️
对于 UB行为，尽量避免，避免语义的不确定性，不要把编译器的实现当作特性。

对于一些UB行为很多时候当成明确的语法错误，有利于程序的开发和维护。
💡比如 在C语言的开发中，尽量使用前缀自增，不使用后缀自增。

### UB定义
![[C++常识#Undefined, unspecified and implementation-defined behavior]]