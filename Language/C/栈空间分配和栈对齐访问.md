### Stack
---
之前对于函数栈空间的理解就是栈空间由系统自动分配自动释放，并且局部变量等数据是存放在栈帧中，**但是栈空间何时分配，栈空间大小等细节还是没有过多了解。**

栈在计算机中就是一块连续的存储区域(至少虚拟地址是连续的)，只不过在这块连续的存储区域写入和删除数据按照先进后出的规则进行，在计算机中使用两个指针就可以完全描述一个栈，bp(base pointer)指向栈底，sp(stack pointer)指向栈顶。

### 栈的生命周期
---
**栈的生命周期是和进程的生命周期保持一致的**，进程在则栈在，进程亡则栈亡。因此，不妨从进程的生命周期探讨栈的生命周期。

一个用户进程从无到开始运行，需要经过几个重要的步骤：

- Linux首先创建一个task_struct用于管理进程的方方面面。这里只是有了进程的“草图”，进程还没有被创建。
- **建立进程的虚拟地址空间，也即建立页表，建立虚拟地址到物理地址的映射**，到这时一个用户进程所需的基本元素已经具备，一个进程被创建完成，在创建进程的过程中，进程的**内核栈**也被创建，内核栈不在本文的说明范围内。
- 接下来就需要可执行文件本身的参与，**读取可执行文件头，解析文件头**，文件头的前几个字节会指出当前文件是何种类型，如果是#!/bin/sh或 #!/bin/python 则该文件是脚本文件，有负责脚本文件的加载程序，本文只关注可执行文件。建立虚拟地址和可执行文件之间的映射。
- 初始化进程环境，其中比较重要的一项便是初始化**用户栈**
- 跳转到可执行文件的入口，执行可执行文件，运行到用户程序main函数，这其中主要右libc对**栈**进行管理。
- main()函数通过切换**栈帧**调用其它子函数，子函数也能通过切换栈帧调用其子函数。
- mian()函数返回，整个进程结束，释放栈占的内存，**栈消失**。

结合上面所述以及下图所示，栈的生命周期可以分为4个部分：

- Linux Kernel创建用户栈，**为栈分配内存空间**，处理传递给用户的参数，将参数压入栈中，压入指向参数的argv，计算出argc并将其压栈。
- libc的`_start`函数将 Linux Kernel创建的栈和libc库函数接上头，由体系结构相关的汇编语言编写，**核心作用是将栈顶地址赋值给SP**，还将Linux设置的栈传递、参数传递以及一些库函数的函数指针传递给C语言编写的函数`__libc_start_mian`。`_start`函数只是起到一个过渡作用，根据CPU的体系结构将Linux Kernel初始化好的栈传递给后续的C语言编写的函数。
- libc的`__libc_start_mian`函数是一个C语言写的函数，运行到该函数时用户栈的结构已经是编译器设计的了，同时由于`_start`函数已经设置好了SP的值，各种压栈、出找操作都在不断调整SP的值。该函数的功能主要有，main调用前的初始化工作；调用main；main函数返回后的清尾工作。
- 编译器设计main函数及其调用的子函数的栈。

![[stacklife.png]]

### 用户栈在系统中的位置
---
对于Linux内核而言，将整个内存空间划分为两个部分，Kernel Space 和User Space。

Kernel Space 用于支撑Linux Kenrel本身的运行所需空间。

User Space就是用于支持用户程序所需的运行空间。用户栈就是位于用户空间，一般位于用户空间的最高部分，向低地址处增长。

![[stackspace.png]]

### 用户进程栈的初始化
---
在进程刚开始运行的时候，**需要知道运行的环境和用户传递给进程的参数**，因此Linux在用户进程运行前，**将系统的环境变量和用户给的参数保存到用户虚拟地址空间的栈中，从栈基地址处开始存放**。若排除栈基地址随机化的影响，在Linux64bit系统上用户栈的基地址是固定的：

在x86_64一般设置为0x0000_7FFF_FFFF_F000：
```cpp
#define STACK_TOP_MAX       TASK_SIZE_MAX
#define TASK_SIZE_MAX        ((1UL << __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)
#define __VIRTUAL_MASK_SHIFT    47
```


在ARM64上是可以配置的，可以通过配置CONFIG_ARM64_VA_BITS的值决定栈的基地址：
```cpp
#define STACK_TOP_MAX       TASK_SIZE_64
#define TASK_SIZE_64             (UL(1) << VA_BITS)
#define VA_BITS                       (CONFIG_ARM64_VA_BITS)
```

为了防止利用缓冲区溢出，Linux会对栈的基地址做随机化处理，[在开启地址空间布局随机化（Address Space Layout Randomization，ASLR)后](https://blog.csdn.net/plus_re/article/details/79199772), 栈的基地址不是一个固定值。

