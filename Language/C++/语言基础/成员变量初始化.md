### 成员变量初始化总结
---
1. 声明时初始化(C++11开始)

2. 初始化列表初始化(变量初始化的顺序是按照定义的顺序)
	以下三种情况下必须使用初始化成员列表  
		1. **需要初始化的数据成员是对象，且该对象不能默认构造**。(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；  
		2. 需要初始化const修饰的类成员；（C++11后，声明时初始化也可以）  
		3. 需要**初始化引用成员数据**；
  
3. 构造函数内初始化
  **关于初始化列表和构造函数内赋值的区别：**
	  1. 对于内置类型（char，int……指针等）: 基本没区别
	  2. 对于自定义类对象的成员初始化
		- **初始化列表**是直接调用拷贝函数构造；
		- 构造函数内赋值是先调用默认构造函数构造（当然，你得保证你定义的类有无参构造函数），在调用重载赋值函数赋值  
		    所以使用初始化列表效率高很多。**能使用初始化列表的时候尽量使用初始化列表**
	  
#### 普通变量
如果不考虑效率的情况下，可以在构造函数中进行赋值。考虑效率可以在构造函数的初始化列表中进行（C++11后可以在声明初始化进行）。

#### static 变量
static 变量属于类所有，而不属于类的对象，因此不管类被实例化了多少个对象，该变量都只有一个。在这种性质上理解，有点类似于全局变量的唯一性。

在C++中，类的静态成员（static member）必须在**类内声明，在类外定义和初始化**
```cpp
class CA
{
public:
	static int sum;
	……
public:
	CA();
	……
};
//静态成员变量在编译时存储在静态存储区，即定义过程应该在编译时完成，
//因此一定要在类外进行定义，但可以不初始化。
int CA::sum;//类外定义，没有初始化
int CA::sum=0;//类外定义，并进行初始化。
```

#### const 变量
const 常量需要在声明的时候即初始化。因此需要在变量创建的时候进行初始化。**一般采用在构造函数的初始化列表中进行（C++11后可以在声明初始化）**。

```cpp
class CA
{
public:
	const int max;
	……
public:
	CA();
	……
};


CA::CA():max(100)
{
……
}
```

#### Reference 引用型变量
引用型变量和const变量类似。需要在创建的时候即进行初始化。也是在初始化列表中进行。但需要注意用Reference类型。

**如果成员为变量为引用类型**  
	类不能有默认无参构造函数，必须提供构造函数  
	类构造函数的形参必须为引用类型  
	引用型成员变量初始化必须在成员初始化列表内完成

```cpp
class CA
{
public:
	int init;
	int& counter;
	……
public:
	CA();
	……
};
// 如果成员为变量为引用类型，那么构造函数的参数为引用类型
// 引用必须在成员初始化列表里面初始化，不能在函数体里面初始化
// 在函数体里面相当于赋值，显然引用不能赋值
 
CA::CA():counter(&init)
{
	……
}
```

#### const static integral 变量
声明初始化

#### 类中的static成员函数的声明和定义
static函数的声明可以像普通成员函数一样声明，只是在前面加上一个static关键字。  
如：
```cpp
private： 
static int GetXYZ();
```

而在**定义**时，像static变量那样，也是必须去掉static关键字，若写成：

```cpp
static int A::GetXYZ()
{
	…………
}
```

就会提示错误：  
‘static’ should not be used on member functions defined at file scope

应该写成是这样：
```cpp
int A::GetXYZ()
{
	…………
}
```

