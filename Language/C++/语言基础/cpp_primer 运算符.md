
### 需要注意的点

#### 计算顺序的问题
[[计算顺序]]

#### 算数运算符

对于大多数运算符，布尔类型的运算对象被提升为 int 类型

注意 int, unsigned int等类型一起计算时的溢出问题(比如 int 类型对象为负值)

- 在除法运算中，如果两个运算符对象的符号相同则商为正， 否则为负
- C++11标准规定商一律向0取整（即切除小数部分 trunk)
- 取余运算的符号, 即 由 被除数的符号决定 
  (-m) / n 和 m / (-n) 都等于  -(m/n)
  m % (-n) == m % n
  (-m) % n  == -(m % n)  
  
- 进行比较运算时除非比较的对象的 bool 类型，否则不要使用字面值 true false
- 除非必须，不要使用后置版本的自增，自减运算符：**由于后自增和后自减期间会构造对象的临时副本，故在不使用返回值的语境中_前自增_或_前自减_运算符通常更有效率。 cpp primer 也解释说对于整数和指针类型，编译器可能对这一额外操作有优化，但是对于复杂的迭代器类型，这额外的工作消耗巨大**
- 在一句语句中混用 解引用和递增运算符   `*pbeg++`

#### 位运算符

**位运算符 关于符号位如何处理没有明确的规定, 所以强烈建议仅将位运算符用于处理无符号类型**
**位运算符的对象是小整型， 则它的值会被自动提升成较大的整数类型。**

```cpp
uint8_t bits = 0233

bits << 8 // bits 会被提升成整型
```

**左移运算符在右侧插入为 0 的二进制位； 右移运算符的行为则依赖其左侧运算符对象的类型： 如果是无符号类型，则左侧插入0 二进制位， 如果是有符号类型， 则决定于具体环境。**

#### sizeof 运算符

- sizeof 运算符所得的值是一个　size_t 类型的 **常量表达式**
- sizeof 并不实际计算运算对象的值。  
这两条其实就是说 sizeof 的是编译期就确定的。

#### 逗号运算符

内建逗号运算符的左边的实参是 弃值表达式

#### 算术转换

无符号类型的运算对象与 有符号类型的运算对象 提升要看具体情况。



