存储类说明符是一个名字的声明语法的**声明说明符序列**的一部分。它与名字的作用域一同控制名字的两个独立性质： 
- “存储期”
- “链接”。 

- auto C++11前， 现已有新的功能
- register 自动存储期，另提示编译器将此对象**置于处理器的寄存器**。(弃用) (C++17 前)
- static 静态或线程存储期和内部链接
- extern 静态或线程存储期和外部链接
- thread_local 线程存储期(C++11起)
- mutable 不影响存储期或链接

声明中只能出现一个存储类说明符，但 thread_local 可以与 static 或 extern 结合 (C++11 起)。 

- auto 该关键词的含义已在C++11变更

- register 已在C++17后弃用

- static 说明符只能搭配（函数形参列表外的）对象声明、（块作用域外的）函数声明及匿名联合体声明。当用于声明类成员时，它会声明一个静态成员。当用于声明对象时，它指定静态存储期（除非与 thread_local 协同出现）。在命名空间作用域内声明时，它指定内部链接。

- extern 声明符**只能搭配变量声明和函数声明（除了类成员或函数形参）**。它指定外部链接，而且技术上**不影响存储期**，但它不能用来定义自动存储期的对象，故所有 **extern 对象都具有静态或线程存储期**。另外，使用 extern 且没有初始化器的声明不是定义。

- thread_local 关键词只能搭配在命名空间作用域声明的对象、在块作用域声明的对象及静态数据成员。它指示对象具有线程存储期。如果对块作用域变量只应用了 thread_local 这一个存储类说明符，那么同时也意味着应用了 static。它能与 static 或 extern 结合，以分别指定内部或外部链接（但静态数据成员始终拥有外部链接）。

### 存储期
---
程序中的所有对象都具有下列存储期之一： 
- 自动（automatic）存储期。这类对象的存储在外围代码块**开始时分配，并在结束时解分配**。未声明为 thread_local、 (C++11 起)static 或 extern 的所有局部对象均拥有此存储期。 

- 静态（static）存储期。这类对象的存储在**程序开始时分配，并在程序结束时解分配**。这类对象只存在一个实例。**所有在命名空间（包含全局命名空间）作用域声明的对象，加上声明带有 static 或 extern 的对象均拥有此存储期**。有关拥有此存储期的对象的初始化的细节，见非局部变量与静态局部变量。 

- 线程（thread）存储期。这类对象的存储**在线程开始时分配，并在线程结束时解分配**。每个线程拥有它自身的对象实例。只有声明为 thread_local 的对象拥有此存储期。thread_local 能与 static 或 extern 一同出现，它们用于调整链接。关于具有此存储期的对象的初始化的细节，见非局部变量和静态局部变量。

- 动态（dynamic）存储期。这类对象的存储是通过使用**动态内存分配函数来按请求进行分配和解分配的**。关于具有此存储期的对象的初始化的细节， 见 [new 表达式](https://zh.cppreference.com/w/cpp/language/new "cpp/language/new")。

### 链接
---
指代**对象、引用、函数、类型、模板、命名空间或值的名字**，可具有链接。如果某个名字具有链接，那么它所指代的实体与另一作用域中的声明所引入的相同名字指代相同的实体。如果有变量、函数或其他实体在数个作用域声明但没有足够的链接，那么就会生成该实体的多个实例。 

#### 无链接
名字**只能从它所在的作用域使用**。 在块作用域声明的下列任何名字均无链接：

- 未显式声明为 extern 的变量（不管有没有 static 修饰符）；
- 局部类和它的成员函数；
- 在块作用域声明的其他名字，例如 typedef、枚举及枚举项。 

未指定为拥有外部、模块 (C++20 起)或内部链接的名字同样无链接，这与它的声明所处的作用域无关。 

#### 内部链接
名字可从**当前翻译单元中的所有作用域使用**。 在**命名空间作用域声明的**下列任何名字均具有内部链接； 

- 类型具有const限定 但没有volatile 限定的非模板（C++14起）变量，除非：
  - 它是内联的（C++17起）
  - 它显式声明未 extern
  - 它已在先前声明，而且先前的声明不具有内部链接；
  - 它在模块接口单元（在私有模块片段以外，如果存在）或模块分区的范围中定义(C++20 起)
  
- 匿名联合体的数据成员（联合体是特殊的类类型，它在一个时刻只能保有其一个非静态[数据成员](https://zh.cppreference.com/w/cpp/language/data_members "cpp/language/data members")。）

另外，**所有在无名命名空间或无名命名空间内**的命名空间中声明的名字，即使显式声明为 extern 也均拥有内部链接。(C++11 起)

#### 外部链接
名字能从其他翻译单元中的作用域使用。具有外部链接的变量和函数也具有[语言链接](https://zh.cppreference.com/w/cpp/language/language_linkage "cpp/language/language linkage")，这使得以不同编程语言编写的翻译单元可以互相链接。 在命名空间作用域声明的下列任何名字均具有外部链接，除非这些名字在无名命名空间内声明或它们在具名模块声明且未被导出 (C++20 起)：

- 未声明为 static 的函数、命名空间作用域内未声明为 static 的非 const 变量，和所有声明为 extern 的变量

- 枚举

- 类以及其成员函数、静态数据成员（不论是否const）、嵌套类以及枚举，及首次以类体内的`friend`声明引入的函数的名字；

- 所有未列于上的模板名（即未声明为 static 的函数模板)

任何首次在块作用域声明的下列名称拥有外部链接：
- 声明为 extern 的变量名
- 函数名



### 自动初始化与静态初始化
---
当控制流到达其定义时，就会初始化**本地自动对象或变量**。 

当控制流首次到达其定义时，将初始化**本地静态对象或变量**。

#### 静态局部变量
在块作用域声明且带有 static 或 thread_local (C++11 起) 说明符的变量拥有**静态或线程 (C++11 起)存储期**，但在控制**首次经过它的声明时才会被初始化**（除非它被零初始化或常量初始化，这可以在首次进入块前进行）。在其后所有的调用中，声明都会被跳过。

如果初始化抛出异常，那么不认为变量被初始化，且控制下次经过该声明时将再次尝试初始化。

如果初始化递归地进入正在初始化的变量的块，那么行为未定义。 

如果多个线程试图同时初始化同一静态局部变量，那么**初始化严格发生一次**（类似的行为也可对任意函数以 [std::call_once](https://zh.cppreference.com/w/cpp/thread/call_once "cpp/thread/call once") 来达成）(初始化是线程安全的， 写操作不是)。

块作用域静态变量的析构函数在初始化已成功的情况下[在程序退出时](https://zh.cppreference.com/w/cpp/utility/program/exit "cpp/utility/program/exit")被调用。

[Site Unreachable](https://www.cnblogs.com/MinPage/p/14613364.html)
### 注意
---
位于顶层命名空间作用域（C 中的文件作用域），且是 const 而非 extern 的名字在 **C 中具有外部链接**，但在 C++ 中具有内部链接。

C++11 起，auto 不再是存储类说明符；它被用于指示类型推导。

为了兼容性（代码可能用c 或 c++ 编译器， 或者新标准的编译器）， 不推荐在代码中使用 register 

从不同作用域指代的且带内部或外部链接的 thread_local 变量的名字可能指代相同或不同的实例，这取决于代码在相同还是不同的线程执行。（理所应当， 线程变量）

extern 关键词也能用来指定[语言链接](https://zh.cppreference.com/w/cpp/language/language_linkage "cpp/language/language linkage")和[显式模板实例化声明](https://zh.cppreference.com/w/cpp/language/class_template "cpp/language/class template")，但它在这些情况中不是存储类说明符（但当声明直接在语言链接说明中所包含时将声明当做如同它含 extern 说明符）。（看不懂）

[关键词 mutable](https://zh.cppreference.com/w/cpp/language/cv "cpp/language/cv") 在 C++ 语言的语法中是存储类说明符，尽管它并不影响存储期或链接。


### 参考
---
[存储类说明符 - cppreference.com](https://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F)