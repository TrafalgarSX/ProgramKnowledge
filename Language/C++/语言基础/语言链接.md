### language linkage
--- 
提供以不同程序语言编写的模块间的连接。
-  extern 字符串字面量 { 声明序列(可选) }  (1)
-  extern 字符串字面量 声明               (2)

1) 将语言说明 字符串字面量 应用到声明于 **声明序列** 中的所有函数类型，具有外部连接的函数名，和具有外部连接的变量。
2) 将语言说明 字符串字面量 应用到单一声明或定义。

所有函数类型，所有拥有**外部连接的函数名**，及所有拥有**外部连接的变量名**，拥有一种称作**语言连接**的性质。

语言连接封装与以**另一程序语言编写的模块**进行连接的要求的集合：调用约定、名字重整的算法，等等。 

仅保证支持二种语言连接：
1) "C++"，默认的语言连接。
2) "C"，使得以 C 程序语言编写的函数进行连接，以及在 C++ 程序中定义能从 C 模块调用的函数成为可能。

因为**语言连接是每个函数类型的一部分**，故函数指针也要维持语言连接。函数类型的语言连接（它表示调用约定）和函数名的语言连接（它表示名字重整）是彼此独立的： 

- 函数名的语言链接  name mangling
- 函数类型的语言链接  调用约定    ❓TODO 不明白 

💡 updata: 大概意思是这里的 `extern "C"`是用来修饰 作为**参数**或者**返回值**的函数的，是函数指针的一部分， 混乱， 很少用到。

```cpp
extern "C" void f1(void(*pf)()); // 声明一个具有 C 连接的函数 f1，
                             // 它返回 void 并接受指向返回 void 且不接受形参的 C 函数的指针
extern "C" typedef void FUNC(); // 声明 FUNC 为返回 void 且不接受形参的 C 函数类型
FUNC f2;            // 名字 f2 拥有 C++ 连接，但其类型是 C 函数
extern "C" FUNC f3; // 名字 f3 拥有 C 连接且其类型是 C 函数 void(void)
void (*pf2)(FUNC*); // 名字 pf2 拥有 C++ 连接，且其类型是“指向返回 void 并接受
                    // 一个‘指向返回 void 且不接受形参的 C 函数的指针’类型参数的 C++ 函数的指针
extern "C" {
    static void f4(); // 函数 f4 的名字拥有内部连接（无语言）
                      // 但函数的类型拥有 C 语言连接
}
```

- 在**同一命名空间中具有相同名字和相同形参列表的两个函数**，不能拥有两个不同的语言连接
- 同一命名空间中的两个变量不能拥有两种不同的语言连接。
#### "C" 连接的特殊规则
1) 当**类成员的声明和成员函数类型的声明**出现于 "C" 语言块中时，其连接仍保持为 "C++"。
2) 当两个拥有同一无限定名字的函数声明于**不同命名空间**，且都拥有 "C" 语言连接时，两个声明表示同一函数。
3) 当两个拥有 "C" 语言连接和相同名字的变量出现于**不同命名空间**时，它们表示同一变量。
   💡`extern "C"` 忽略了命名空间的作用， 即使命名空间不同， 也表示同一变量或函数
4) 一个 "C" 变量和一个 "C" 函数不能拥有相同的名字，无关乎它们定义于同一或不同命名空间。

#### 注意
- 语言说明的花括号不建立作用域
  ```cpp
  extern "C"{
     // 这里不建立作用域
  }
```

- 当语言说明发生嵌套时，有效的是最内层的说明。

- 函数可在**带语言说明的声明之后，进行不带连接说明的重声明**，第二个声明将重复使用首个声明的语言连接。**反之则不行**：若首个声明无语言连接，则假定其为 "C++"，而以其他语言连接重声明则是错误。 
