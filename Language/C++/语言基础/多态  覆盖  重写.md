### 多态的原理及产生过程

1. 用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
2. 存在虚函数的类都有一个一维的虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
3. 多态性是一个接口多种实现，是面向对象的核心。分为类的多态性和函数的多态性。
4. 多态用虚函数来实现，结合动态绑定。
5. 纯虚函数是虚函数再加上= 0。
6. 抽象类是指包括至少一个纯虚函数的类。

[纯虚函数](https://so.csdn.net/so/search?q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)：virtual void breathe()=0；即抽象类！必须在子类实现这个函数!即先有名称，没内容，在派生类实现内容!

**多态**：简单概括为一个接口，多种方法，程序再运行时才决定要调用的函数。  
实现动态多态的条件：  
1>基类必须包含[虚函数](https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)，在派生类中必须对基类中的虚函数进行重写  
2>通过基类的指针或引用来调用虚函数

### override/重写/覆盖
**重写**：c++的多态性是通过虚函数重写来实现的，虚函数允许派生类重新定义成员函数，而派生类重新定义基类的做法称为覆盖或者重写  
**重写的条件**：  
1>在派生类中要重写的函数在基类中必须是虚函数  
2>派生类中虚函数必须要与基类中虚函数原型保持一致  
3>派生类中函数[virtual](https://so.csdn.net/so/search?q=virtual&spm=1001.2101.3001.7020)可加可不加，仍然保持虚函数特性  
4>基类与派生类虚函数的访问权限可以不同，注意：基类中虚函数必须是public  
5>有两个特例：析构函数（函数名不同），但是可以是重写，另一个是**协变**（基类虚函数返回基类的引用或指针，派生类虚函数返回派生类的引用或指针，基类与派生类的返回值类型个不同）  
**重写总结**：  
1>不在同一作用域(分别在基类和派生类)  
2>函数名相同/参数相同/返回值相同（协变，析构除外）  
3>基函数必须有virtual关键字  
4>访问修饰符可以不同  

override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。
重写（覆盖）的规则：
1、**重写方法的参数列表必须完全与被重写的方法的相同**,否则不能称其为重写而是重载.
2、重写方法的**访问修饰符一定要大于被重写方法的访问修饰符**（public>protected>default>private）。
3、重写的方法的**返回值必须和被重写的方法的返回一致；**
4、重写的方法**所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；**
5、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。
6、静态方法不能被重写为非静态的方法（会编译出错）。

### 重定义/隐藏
**重定义**：  
1>在不同作用域（分别在基类和派生类）  
2>函数名相同  
3>在基类和派生类中只要不构成重写就是重定义  

overload是重载，一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。
重载的规则：
1、在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（参数类型必须不一样）；
2、**不能通过访问权限、返回类型、抛出的异常进行重载；**
3、方法的异常类型和数目不会对重载造成影响；

### 重载
**重载**：  
1>在同一作用域  
2>函数名相同  
3>参数列表不同（参数个数，类型，顺序）


### 参考
---
[Virtual method table - Wikipedia](https://en.wikipedia.org/wiki/Virtual_method_table)

[C++成员函数的重载、覆盖与隐藏详解\_qt覆写父类成员-CSDN博客](https://blog.csdn.net/gatieme/article/details/50899343)