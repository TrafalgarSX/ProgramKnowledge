
## å…¨å±€å˜é‡ã€staticå˜é‡åˆå§‹åŒ–æ—¶é—´

### [é™æ€å±€éƒ¨å˜é‡](https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020)

é¦–å…ˆï¼Œé™æ€å±€éƒ¨å˜é‡å’Œå…¨å±€å˜é‡ä¸€æ ·ï¼Œæ•°æ®éƒ½å­˜æ”¾åœ¨å…¨å±€åŒºåŸŸï¼Œæ‰€ä»¥åœ¨ä¸»ç¨‹åºä¹‹å‰ï¼Œç¼–è¯‘å™¨å·²ç»ä¸ºå…¶åˆ†é…å¥½äº†å†…å­˜ï¼Œä½†åœ¨Cå’ŒC++ä¸­é™æ€å±€éƒ¨å˜é‡çš„åˆå§‹åŒ–èŠ‚ç‚¹åˆæœ‰ç‚¹ä¸å¤ªä¸€æ ·ã€‚

- åœ¨Cä¸­ï¼Œåˆå§‹åŒ–å‘ç”Ÿåœ¨ä»£ç æ‰§è¡Œä¹‹å‰ï¼Œç¼–è¯‘é˜¶æ®µåˆ†é…å¥½å†…å­˜ä¹‹åï¼Œå°±ä¼šè¿›è¡Œåˆå§‹åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°**åœ¨Cè¯­è¨€ä¸­æ— æ³•ä½¿ç”¨å˜é‡å¯¹é™æ€å±€éƒ¨å˜é‡è¿›è¡Œåˆå§‹åŒ–**ï¼Œåœ¨ç¨‹åºè¿è¡Œç»“æŸï¼Œå˜é‡æ‰€å¤„çš„å…¨å±€å†…å­˜ä¼šè¢«å…¨éƒ¨å›æ”¶ã€‚

- è€Œåœ¨C++ä¸­ï¼Œåˆå§‹åŒ–æ—¶åœ¨æ‰§è¡Œç›¸å…³ä»£ç æ—¶æ‰ä¼šè¿›è¡Œåˆå§‹åŒ–(â—**æ„Ÿè§‰ä¸å®Œå…¨å¯¹**)ï¼Œä¸»è¦æ˜¯ç”±äºC++å¼•å…¥å¯¹è±¡åï¼Œè¦è¿›è¡Œåˆå§‹åŒ–å¿…é¡»æ‰§è¡Œç›¸åº”æ„é€ å‡½æ•°å’Œ[ææ„å‡½æ•°](https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)ï¼Œåœ¨æ„é€ å‡½æ•°æˆ–ææ„å‡½æ•°ä¸­ç»å¸¸ä¼šéœ€è¦è¿›è¡ŒæŸäº›ç¨‹åºä¸­éœ€è¦è¿›è¡Œçš„ç‰¹å®šæ“ä½œï¼Œå¹¶éç®€å•åœ°åˆ†é…å†…å­˜ã€‚æ‰€ä»¥C++æ ‡å‡†å®šä¸ºå…¨å±€æˆ–é™æ€å¯¹è±¡æ˜¯æœ‰é¦–æ¬¡ç”¨åˆ°æ—¶æ‰ä¼šè¿›è¡Œæ„é€ ï¼Œå¹¶é€šè¿‡atexit()æ¥ç®¡ç†ã€‚åœ¨ç¨‹åºç»“æŸï¼ŒæŒ‰ç…§æ„é€ é¡ºåºåæ–¹å‘è¿›è¡Œé€ä¸ªææ„ã€‚æ‰€ä»¥**åœ¨C++ä¸­æ˜¯å¯ä»¥ä½¿ç”¨å˜é‡å¯¹é™æ€å±€éƒ¨å˜é‡è¿›è¡Œåˆå§‹åŒ–**çš„ã€‚

- å…¨å±€å˜é‡ã€æ–‡ä»¶åŸŸçš„é™æ€å˜é‡å’Œç±»çš„é™æ€æˆå‘˜å˜é‡åœ¨**mainæ‰§è¡Œä¹‹å‰**çš„é™æ€åˆå§‹åŒ–è¿‡ç¨‹ä¸­åˆ†é…å†…å­˜å¹¶åˆå§‹åŒ–ï¼›

- å±€éƒ¨é™æ€å˜é‡ï¼ˆä¸€èˆ¬ä¸ºå‡½æ•°å†…çš„é™æ€å˜é‡ï¼‰åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶åˆ†é…å†…å­˜å¹¶åˆå§‹åŒ–ã€‚è¿™é‡Œçš„å˜é‡åŒ…å«å†…ç½®æ•°æ®ç±»å‹å’Œè‡ªå®šä¹‰ç±»å‹çš„å¯¹è±¡ã€‚**

### å…¨å±€å˜é‡

æ ¹æ® C++ æ ‡å‡†ï¼Œ**å…¨å±€å˜é‡çš„åˆå§‹åŒ–è¦åœ¨ main å‡½æ•°æ‰§è¡Œå‰å®Œæˆ**ï¼Œå¸¸è¯†æ— ç–‘ï¼Œä½†æ˜¯è¿™ä¸ªè¯´æ³•æœ‰ç‚¹å«ç³Šï¼Œmain å‡½æ•°æ‰§è¡Œå‰åˆ°åº•å…·ä½“æ˜¯ä»€ä¹ˆæ—¶å€™å‘¢ï¼Ÿæ˜¯ç¼–è¯‘æ—¶è¿˜æ˜¯è¿è¡Œæ—¶ï¼Ÿ**ç­”æ¡ˆæ˜¯æ—¢æœ‰ç¼–è¯‘æ—¶ï¼Œä¹Ÿå¯èƒ½ä¼šæœ‰è¿è¡Œæ—¶(seriously)**, ä»è¯­è¨€çš„å±‚é¢æ¥è¯´ï¼Œå…¨å±€å˜é‡çš„åˆå§‹åŒ–å¯ä»¥åˆ’åˆ†ä¸ºä»¥ä¸‹**ä¸¤ä¸ªé˜¶æ®µ**ï¼ˆc++11 N3690 3.6.2)ï¼š

### The Two Stages of Static Variable Initialization
As discussed, variables with _static storage duration_ must be initialized once **before the program starts and destroyed after execution terminates**. Initialization of static variables should be simple, but off course it isnâ€™t. And, as always, you can do a lot of self damage if you are not careful.

Initialization of static variables happens in two consecutive stages: 

- _static_ initialization
- _dynamic_ initialization.

**Static initialization** happens first and usually at **compile time**. If possible, initial values for static variables are **evaluated during compilation and burned into the data section of the executableï¼ˆåˆå§‹å€¼å†™åœ¨æ–‡ä»¶ä¸­ï¼‰**. Zero runtime overhead, early problem diagnosis, and, as we will see later, safe. This is called [constant initialization](https://en.cppreference.com/w/cpp/language/constant_initialization). In an ideal world all static variables are const-initialized.

If the initial value of a static variable **canâ€™t be evaluated at compile time**, the compiler will perform **zero-initialization**. 
ğŸ’¡Hence, during static initialization all static variables are **either const-initialized or zero-initialized.**

åœ¨é™æ€åˆå§‹åŒ–æœŸé—´ï¼Œæ‰€æœ‰é™æ€å˜é‡è¦ä¹ˆè¢«**å¸¸é‡åˆå§‹åŒ–**ï¼Œè¦ä¹ˆè¢«**é›¶åˆå§‹åŒ–**ã€‚

**After static initialization**, **dynamic initialization** takes place. Dynamic initialization happens **at runtime** for variables that canâ€™t be evaluated at compile time[2](https://pabloariasal.github.io/2020/01/02/static-variable-initialization/#fn:1). Here, static variables are initialized every time the executable is run and not just once during compilation.

### Constant Initialization
**Constant initialization (i.e. compile time)** is ideal, thatâ€™s why your compiler will try to perform it whenever it can. This is the case when your variable is initialized by a [constant expression](https://en.cppreference.com/w/cpp/language/constant_expression), that is, an expression that can be evaluated at compile time.

```cpp
//a.cpp
struct MyStruct
{
    static int a;
};
int MyStruct::a = 67;

```

### Force Const Initialization with constexpr
â“**One big problem with static variable initialization** is that it is not always clear if a variable is being initialized at compile time or at runtime.

One way to make sure that variables are const-initialized (i.e. compile time) is by declaring them `constexpr`, **this will force the compiler to treat them as constant expressions and perform their evaluation and initialization at compile time.**

`constexpr` must be your first choice when declaring global variables (assuming you really need a global state to begin with). `constexpr` variables are not just initialized at compile time, but `constexpr` implies `const` and immutable state is always the right way.

### Your Second Line of Defense: `constinit`

`constinit` is a keyword introduced in the c++20 standard. It works just as `constexpr`, as it forces the compiler to evaluate a variable at compile time, but with the difference that it **doesnâ€™t imply const**.

As a consequence, variables declared `constinit` are always const-(or zero-)initialized, but can be mutated at runtime, i.e. donâ€™t land in read-only data section in the binary.

### The Yellow Zone - Dynamic Initialization
Imagine you need an immutable global `std::string` to store the software version. You probably donâ€™t want this object to be instantiated every time the program runs, but rather create it once and embed it into the executable as read-only memory. In other words, you want `constexpr`:

```cpp
constexpr auto VERSION = std::string("3.4.1");
```

But life isnâ€™t that easy:
```
error: constexpr variable cannot have non-literal type
```

â“TODO what is non-trivial destructor ?
The compiler is complaining because `std::string` defines a **non-trivial destructor**. That means that `std::string` is probably **allocating some resource that must be freed upon destruction**, in this case memory. This is a problem, if we create an `std::string` at compile time the managed memory must be somehow copied into the binary as well, as it wonâ€™t be available when the executable is run!

In other words, `std::string("3.4.1")` is not a constant expression so we canâ€™t force the compiler to const-initialize it!

We must give up:
```cpp
const auto VERSION = std::string("3.4.1");
```

Your compiler is happy, but for **the price of moving the initialization from compile time to runtime**. `VERSION` must be initialized as part of dynamic initialization, not static.

Good news is that at runtime we can allocate memory. Bad news is that this **isnâ€™t as nice, saf, or efficient** as static initialization, but isnâ€™t inherently bad either. 

Dynamic initialization will be **inevitable** in some cases, **not everything can be done at compile time**, for example:

```cpp
// generate a random number every time executable is run
const auto RANDOM = generateRandomNumber();
```

The future looks bright, however. Even when moving slowly, **smart people have been working on several proposals to augment the capabilities of `constexpr` to types like `std::string` or `std::vector`**. The idea here is to allow for memory allocations at compile time and later flash the object alongside its managed memory into the data section of the binary.

### The Red Zone - Static Initialization Order Fiasco
Dynamic initialization of static variables suffers from a very scary defect: the order in which variables are initialized at runtime is not always well-defined.

Within a **single compilation unit**, static variables are initialized **in the same order as they are defined** in the source (this is called _Ordered Dynamic Initialization_). 

**Across compilation units**, however, the order is undefined: **you donâ€™t know** if a static variable defined in `a.cpp` will be initialized before or after one in `b.cpp`.

This turns into a very serious issue if the initialization of a variable in `a.cpp` depends on another one defined `b.cpp` . This is called the [Static Initialization Order Fiasco](https://isocpp.org/wiki/faq/ctors#static-init-order). Consider this example:

```cpp
// a.cpp
int duplicate(int n)
{
    return n * 2;
}
auto A = duplicate(7); // A is dynamic-initialized
```

```cpp
// b.cpp
#include <iostream>

extern int A;
auto B = A; // dynamic initialized

int main()
{
  std::cout << B << std::endl;
  return EXIT_SUCCESS;
}
```

This program is ill-formed. It may print `14` or `0` (all static variables are at least zero-initialized during static initialization), depending if the dynamic initialization of `A` happens before `B` or not.

ğŸ’¡Note that **this problem can only happen during the dynamic initialization phase and not during static initialization**, (è§£é‡Šï¼š)as during compile time it is impossible to access a value defined in another compilation unit. This makes compile time initialization so **much safer** than dynamic initialization, as it doesnâ€™t suffer from the static initialization order fiasco.

### Solving The Static Initialization Order Fiasco
Encountering the static initialization order fiasco is **often a symptom of poor software design**. IMHO the best way to solve it is by refactoring the code to break the initialization dependency of globals across compilation units. **Make your modules self-contained and strive for constant initialization.**

If refactoring is not an option, one common solution is the [Initialization On First Use](https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use). The basic idea is to design your static variables that are not constant expressions (i.e. those that must be initialized at runtime) in a way that they are created _when they are accessed for the first time_. This approach uses a static local variable inspired by the [Meyerâ€™s Singleton](http://laristra.github.io/flecsi/src/developer-guide/patterns/meyers_singleton.html). With this strategy it is possible to control the time when static variables are initialized at runtime, **avoiding use-before-init.**


```cpp
// a.cpp
int duplicate(int n)
{
    return n * 2;
}

auto& A()
{
  static auto a = duplicate(7); // Initiliazed first time A() is called
  return a;
}

```

```cpp
// b.cpp
#include <iostream>
#include "a.h"

auto B = A();

int main()
{
  std::cout << B << std::endl;
  return EXIT_SUCCESS;
}

```

### å‚è€ƒ
[C++ - Initialization of Static Variables | pablo arias](https://pabloariasal.github.io/2020/01/02/static-variable-initialization/)