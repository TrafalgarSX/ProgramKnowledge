### 左值和右值的概念
左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、"right value" 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。

右值可以看作程序运行中的临时结果，右值引用可以避免复制提高效率。

左值与右值这两个概念是从C中传承而来的。
~~- 左值是指既能够出现在等号左边，又能够出现在等号右边的变量。··
~- 右值是指只能出现在等号右边的变量~~
**上面的表述通俗理解，很多情况下并不正确**
```C
int a;  // a is lvalue
a = 3;  // 3 is rvalue

(a + 1)  = 4;  //wrong!
```
- 左值是可寻址的变量，有持久性
- 右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。
#### 简单的定义
左值： 表示了一个占据内存中某个可识别的位置（也就是地址）的对象。
右值：使用排除法来定义。一个表达式不是左值就是右值。那么，右值是一个不表示内存中某个可识别位置的对象的表达式。

常量 `4` 和表达式 `var + 1` 都不是左值（也就是说，它们是右值），**因为它们都是表达式的临时结果，而没有可识别的内存位置**（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。

```c++
int foo() {return 2;}  
  
int main()  
{  
    foo() = 2;  //wrong  赋值语句的左边应当是一个左值
  
    return 0;  

error: lvalue required as left operand of assignment
}
```

然而，给函数返回的结果赋值，**不一定总是错误的操作**。例如，C++的引用让我们可以这样写：
```c++
int globalvar = 20;

int& foo()
{
    return globalvar;
}

int main()
{
    foo() = 10;
    return 0;
}
```
这里`foo`返回一个引用。**引用一个左值**，因此可以赋值给它。实际上，C++中函数可以返回左值的功能对实现一些重载的操作符非常重要。eg:
一个常见的例子就是重载方括号操作符[]，来实现一些查找访问的操作，如`std::map`中的方括号：
```c++
std::map<int, float> mymap;  
mymap[10] = 5.6;
```
之所以能赋值给 `mymap[10]`，是因为 `std::map::operator[]` 的重载返回的是一个可赋值的引用。


#### 可以修改的左值
左值一开始在C中定义为`可以出现在赋值操作左边的值`.然而，当ISO加入const关键字后，这个定义便不再成立。eg:
```c
const int a = 10; // 'a' 是左值  
a = 10;           // 但不可以赋值给它！
```
于是定义需要继续细化。不是所有的左值都可以被赋值。可赋值的左值被称为`可修改的左值(midifiable lvalues)`。C99标准定义可修改左值为：
```text
[…] 可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 struct 或 union，它的成员都（递归地）不应含有 const 修饰的类型。
```

#### 左值与右值的转换
计算对象的值的语言成分，都是用右值作为参数。例如，两元加法操作符 '+' 就需要两个右值参数，并返回一个右值：
```c
int a = 1;     // a 是左值
int b = 2;     // b 是左值
int c = a + b; // + 需要右值，所以 a 和 b 被转换成右值
               // + 返回右值
```
在第三行中，它们经历了隐式的 左值到右值转换 。除了数组、函数、不完整类型的所有左值都可以转换为右值。
>《c++ primer》有更精确的描述：当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（在内存中的位置）。

右值能否转换成左值呢？ 不能！ 因为这违反了左值的定义（左值的本质）

不过，右值可以通过一些方式产生左值。例如，一元解引用操作符`*`需要一个右值参数，但返回一个左值结果。
```c
int arr[] = {1, 2};
int* p = &arr[0];
*(p + 1) = 10;   // 正确: p + 1 是右值，但 *(p + 1) 是左值
```
**相反的，一元取地址操作符`&`需要一个左值参数，返回一个右值:**
```c
int var = 10;
int* bad_addr = &(var + 1); // 错误: 一元 '&' 操作符需要左值参数
int* addr = &var;           // 正确: var 是左值
&var = 40;                  // 错误: 赋值操作的左操作数需要是左值
```
在 C++ 中 '&' 符号还有另一个功能——定义引用类型。引用类型又叫做“左值引用”。因此，不能将一个右值赋值给（非常量的）左值引用：
```c
std::string& sref = std::string();  // 错误: 非常量的引用 'std::string&' 错误地使用右值 'std::string` 初始化
```

💡**常量的左值引用 可以使用右值赋值。因为你无法通过常量的引用修改变量的值，也就不会出现修改了右值的情况。这也使得 C++ 中一个常见的习惯成为可能：函数的参数使用常量引用接收参数，避免创建不必要的临时对象。**

lvalue:
`An expression that designate an object is called an lvalue`

### CV限定中的右值
TODO

### C++11的右值引用
TODO

### 左值引用和右值引用
- 左值引用： 引用一个对象
- 右值引用：就是必须绑定到右值的引用， C++11中右值引用可以实现`移动语义`,通过`&&`获得右值引用。
```
int x = 6; // x is lvalue, 6 is rvalue
int &y = x; // 左值引用 y引用x

int &z1 = x * 6 //错误， x*6 是一个右值 非常亮的左值引用&z1
const int &z2 = x *6 //正确，可以将一个const引用绑定到一个右值

int &&z3 = x * 6; //正确， 右值引用
int &&z4 = x; //错误， x是一个左值
```

右值引用和相关的`移动语义`是C++11标准中引入的最强大的特性之一，通过std::move()可以避免无谓的复制，提高程序性能。



### 参考
[理解 C/C++ 中的左值和右值 | nettee 的 blog](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)