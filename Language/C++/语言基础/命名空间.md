### 命名空间的定义
---
```cpp
namespace Name{

}
```
命名空间可以解决命名冲突的问题。

如果 命名空间是全局的，那么 命名空间内的变量也是全局变量

命名空间和非命名空间中相同命名的结构体，变量，函数等不会发生冲突（重定义）

💡 :: 叫做作用域限定符

### 命名空间的内容
---
命名空间里面可以存放变量，函数，结构体，类等

命名空间还可以嵌套
```cpp
namespace AAAAA{
	namespace AAAA{
        namespace AAA{
        }	
	}
}
```

📌 注意事项：虽然套了这么多层，但是它们仍然都是全局的，只是套在了一个命名空间内而已。

### 命名空间重名问题
---
❓ 命名空间是用来解决命名冲突问题的，那我项目中定义的某个命名空间的名字和其他命名空间的名字冲突了怎么办？

其实， 在同一个工程中是允许存在多个相同名称的命名空间的。

编译器最后会将他们合成到同一个命名空间中的。有两个相同名字的命名空间，就会合二为一。有三个相同名字的命名空间，就会三合一……

### 匿名命名空间
---
```cpp
// 匿名命名空间
namespace {
	char c;
	int i;
	double d;
}
```

这种情况，编译器会在内部给这个没有名字的 "匿名命名空间" 生成一个惟一的名字。

并且还会为该匿名命名空间生成一条 using 指令，所以上面的代码会等同于：
```cpp
namespace _UNIQUE_NAME {
	char c;
	int i;
	double d;
}
using namespace _UNIQUE_NAME;
```

### 使用命名空间中成员的方式
---
#### 命名空间展开
```cpp
using namespace Name;
```

但是！！！ 全部展开，虽然使用起来方便，但是隔离的效果失效了！ 工程内如果都用这种写法会导致命名空间污染。

#### 指定命名空间的某个成员
可以用来展开命名空间中最常用的成员：
```cpp
using Name::member
```

#### 空间名+作用域限定符
```cpp
Name::member
```

这种方式最好也最常见。o

### 命名空间污染
---
在程序中经常需要引用一些库，如C++[编译系统](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink)提供的标准库、由[第三方软件](https://baike.baidu.com/item/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6?fromModule=lemma_inlink)开发商提供的开发库或者用户自己开发的库等。如果在这些库中含有与程序中定义的全局实体同名的实体，或者不同的库之间有同名的实体，则在编译时都会出现名字冲突，这就称为全局命名空间污染

Example:
`ispunct`是`cctype`库中定义的一个用来判断一个字符是否为标点符号的函数

由于C++在标准库STL中也定义了`ispunct`函数，定义于`std`命名空间，且是一个模板函数。由于程序直接通过`using namespace std`导入了`std`命名空间，程序默认使用STL库中的`ispunct`，导致编译器直接使用了未特化的模板函数，并未使用`cctype`库中的此函数，因此编译无法通过。

为了避免此类问题出现，我们应该禁止使用using指示，即`using namespace`，而应该使用using声明。由于`std`命名空间定义了很多标识符，直接导入全部的`std`命名空间会产生严重的命名空间污染问题。

谷歌 C++代码规范中有：
```
You may not use a using-directive to make all names from a namespace available.
```