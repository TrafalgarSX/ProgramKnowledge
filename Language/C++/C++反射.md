反射是指程序在运行时动态获取对象属性与方法的一种机制，即编译器需要将**类型信息(属性类型与偏移地址以及成员函数的地址等信息)** 编译到程序文件中，当程序运行时将这些信息加载到内存中去，做到**运行时只根据对象的地址或引用就可以获取到对象的类型信息**，从而利用这些信息达到修改或重建对象的目标。

21世纪以前内存与带宽一直是非常昂贵的资源，编译器在生成可执行文件时要兼顾系统内存等硬件资源，**为节省成本不会将类型信息加载到运行内存中去**。

网络传输也要考虑带宽与各节点的性能，往往需要各通讯节点间采用紧致、简单、高效的通讯协议，这期间编程世界是C/C++的天下，网络上传输的是C/C++语言中的结构体，把结构体当作通讯协议具有无需序列化与反序列化的优点，完美契合当时的软硬件环境。

一直以来，C++都未能支持反射机制，在C++中要实现类似Java等语言的反射机制需要另外写代码保存类型相关信息，然后在运行时使用。后来C++引入了`typeid`运算符，可以在运行时获取类型相关信息，说明C++在编译时是会保存类型相关信息的，只是C++标准要求保存的运行时类型信息不足以支撑类似Java的反射机制。

C++编译器完全可以将类型信息与虚函数表一起保存，在现有虚函数表里面附加类型信息，然后可以通过对象的虚函数表针对找到对象的类型信息。这种方案不会破坏C++原有的对象内存模型，只是拓展了虚函数表的功能。

当然，我们也可以写额外的代码来保存类型信息，然后在运行时获取保存的类型信息来实现反射功能。下面我们实现一个ReflectHelper类，该类以map的方式管理类成员的名称、类型、偏移地址等信息，map键值为类的名称。
[谈谈C++如何实现反射机制 - 知乎](https://zhuanlan.zhihu.com/p/70044481)

[我所理解的 C++ 反射机制\_c++反射机制\_恋喵大鲤鱼的博客-CSDN博客](https://blog.csdn.net/K346K346/article/details/51698184)