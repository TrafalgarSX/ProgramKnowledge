### 问题
---
公司的项目在编译visual studio 2019 工程的时候发现可以链接 visual studio 2008 工程生成的 dll， 但是cmake 链接对应的 lib 时确出了错（需要重新确认）。

引出了我新一轮的搜索， 下面是对搜索的一些总结。

### 现象
---
我以为 dll 是平台相关的， 但实际上并不是， msvc 明确声明过vs2015前的 静态库， 动态库， 可执行文件的二进制兼容性并不保证， 只有 vs2015 后的会保证， 并且要求用新的工具链兼容旧的，比如 vs2017 链接 vs2015 的。

那为什么上面的问题会出现呢？

我估计是 因为上面说的 二进制的兼容性主要是针对 c++, c 语言的二进制兼容性比c++好的多， 所以才有可能出现上面的可以链接 vs2008 生成dll 的情况（为什么链接.lib不行，还不清楚，需要测试了解）。

❗还有就是我以为cmake 链接 dll，如果没有对应的.lib文件， cmake 会自动生成， 实际上并不是， 我本地用vs2022测试，**发现链接.dll 文件,对应的.lib文件必不可少。** 所以最好还是同一个编译器出来的好啊。

#### # Visual Studio 版本之间的 C++ 二进制兼容性 详细解析
[C++ 二进制兼容性 2015-2022 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/porting/binary-compat-2015-2017?view=msvc-170)

### 教训总结
---
无论是 Linux 还是 Windows 工程最好还是用同一个编译器编译， 尤其是 C++ 工程， C++的 ABI 兼容性不好， C 的ABI 兼容性好很多，工程遇见的问题可能少一些， 但是不应该花时间追踪到哪些变化引起了这个问题，为了避免这样的问题，使用统一版本的编译器编译是最好的处理方式，越简单越暴力越美好。



### ABI 知识补充
---
`ABI (Application Binray interface)` : 应用程序二进制接口，描述了应用程序和操作系统之间，一个应用和它的库之间，或应用的组成部分之间的底层接口。

`ABI`从名字上看是二进制接口，而二进制文件再`linux`以`ELF`文件类型表示，`windows`以`PE-COFF`文件类型表示。

二进制文件的生成是通过编译器或者链接器，那么`API`和`ABI`都是谁需要去遵循这个规则呢，如下面的代码假设它将会被编译成一个`myso`动态库，你可以将它当成一个`API`。

```c
int Add(int a, int b) {
  return a + b;
}

int main(void) {
  int c = Add(3, 2);
  return 0;
}
```

- API：库的使用者可能需要去遵循这个接口规范，`Add`函数的参数个数以及参数类型等等。
- ABI：`main`使用到了`Add`这个`API`，这个`API`包含再一个`myso`动态库里面，现在设计到一个符号寻找机制，即编译器需要去`myso`动态库里面寻找`Add`这个符号，那符号的命名规则不一致会导致什么结果？如`gcc1.0`版本的符号命名规则是在函数前面加一个`_`，即最后`Add`符号名称`_Add`, `gcc2.0`版本的符号命名规则是在函数后面加一个`_`, 即最后Add符号名称`Add_`。

思考一个问题，`myso`是利用`gcc1.0`版本编译，`main`使用`gcc2.0`版本编译，会出现是什么问题？ 编译器会提示你`Add_`符号未定义，**这里说的符号导出规则也就是属于`ABI`兼容问题。**

💡结论 ：影响你`API`不兼容的可能是你使用的`API`新增了参数。影响`ABI`不兼容的可能仅仅就是编译器版本不同，一个是源码层面，一个是编译器层面（或者说二进制层面，即编译器生成的二进制）, 当然编译器仅仅只是导致ABI不兼容的一个方面。

#### 影响 ABI 兼容的因素
##### 硬件- 如处理器
思考一个非常简单的问题，最近`Apple`发布了最新款`Mac`笔记本，号称可以直接使用`iPhone`和`ipad`的应用，怎么做到的？

这个就是一个二进制兼容问题，`Apple`再最新的`Mac`笔记本上放弃了之前一直使用的`intel`芯片，从而采用自研的`M1`芯片，这个`M1`的自研芯片架构就是`ARM`架构和苹果`A`系列芯片架构一样，从而才有可能实现二进制级别的兼容。

💡二进制里面包含了指令和数据，**而`CPU`有一个核心作用就是处理指令，不同架构的`CPU`指令集都不同，从而产生的二进制也会不同**，例如你在代码中调用了`print`函数，最终在`X86`生成的二进制文件的一条指令是`call 0x1234`, 但是在`ARM`处理器下它可能没有`call`指令，它的跳转指令可能是`jar`。

##### 操作系统
❓ 为什么不同系统不能兼容同一个已编译的可执行二进制文件（**假设在统一架构**）？

**一、二进制文件类型**

一个可执行的二进制文件包含的不仅仅是机制指令，还包括各种数据、程序运行资源。

如上面提到的二进制文件类型:

- windows - `PE-COFF`
- linux - `ELF`
- macos - `MACH-O`

它们的二进制文件格式各不相同，导致`windows`无法解析`linux`下的`ELF`文件格式，从而无法完成可执行文件在执行之前的一系列初始化操作， 如ELF文件头中就包含了：

|成员|readelf输出结果与含义|
|:-:|:--|
|e_ident|Magic:        7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  <br>Class:         ELF64  <br>Data:          2's complement, little endian  <br>Version:     1(current)  <br>OS/ABI:     UNIX-System V  <br>ABIVersion: 0|
|e_type|ELF文件类型|
|e_machine|ELF文件的CPU平台属性，如X86-64|
|e_version|ELF版本号，一般是0x1|
|e_entry|入口点地址，规定了ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令|
|e_phoff|程序头起点|
|e_shoff|段表咋i文件中的偏移|
|e_word|ELF标志位|
|e_ehsize|ELF文件头本身的大小|
|e_phentsize|程序头的大小|
|e_phnum|程序头数量|
|e_shentsize|段表描述符的大小|
|e_shnum|段表描述符的数量|
|e_shstrndx|段表字符串表所在的段在段表中的下标|

**ELF格式解析不正确，也就不能正常得到上面的数据**，程序入口地址都不知道在哪里，程序从何处开始执行？

**二、程序库不同（API）**

文件操作、输入输出、内存申请释放、任务调度等都需要用到**特定操作系统的特定库**。


##### 编译器
如`C++`函数 name mangling：函数签名的目的就是让编译器能够根据对应的签名规则生成一个符号，编译器根据这个符号来识别和处理函数，函数签名包含了一个函数的信息，其中包括

- 函数名
- 参数类型
- 参数个数
- 类名
- 名称空间

gcc和vc++的函数签名规则都不一样，那gcc编译的库vc++能够找到它的符号吗，答案肯定是不行的。

**就算是不同版本的gcc也一样可能出现二进制不兼容，如gcc4.9版本C++ string,list符号命名和gcc5.1之后的符号命名都是不同的gcc5.1上会增加__cxx11**，所以一样会产生在gcc4.9编译的库，再gcc5.1上使用不了（符号未定义，如果使用了string，list）

##### 语言， 如C++
- 内置类型的大小以及对齐方式（如大端、小端）。
    
- `struct`、`union`、数组等的存储方式和**内存分布**。
    
- **函数调用方式**，比如**参数入栈顺序、返回值如何保持**等。
    
- 堆栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等。
    
- **继承类体系的内存分布**，如基类、虚基类再继承类中的位置等。
    
- **指向成员函数的指针的内存分布**，如何传递this指针
    
- 如何调用虚函数，`vtable`的内容和分布形式，`vtable`指针在`object`中的位置等。
    
- `templte` 如何实例化
    
- 外部符号的修饰
    
- 全局对象的构造和析构
    
- 异常的产生和捕获机制
    
- `RTTI`如何实现

##### 语言， 如C
对于C语言的目标代码来说，以下几个方面会决定目标文件之间是否二进制兼容：  
（1）内置数据类型（如char、int、float等）的大小和**在存储器中的存放方式（大端、小端、对齐方式等）**；  
（2）组合数据类型（struct、union等）的存储方式和内存分布；  
（3）外部符号和用户定义的符号之间的命名方式和解析方式。比如函数名func在C语言目标文件中是否会被解析成外部符号_func；  
（4）函数调用方式，比如参数入栈顺序、返回值如何保存等；  
（5）函数栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等；  
（6）寄存器使用约定，函数调用时哪些寄存器可以修改，哪些需要保存等。