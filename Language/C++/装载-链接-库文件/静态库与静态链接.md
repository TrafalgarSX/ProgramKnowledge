### 静态库
---
链接器读取**一组可重定位目标文件**，并把它们组合称为一个单一的可执行文件。

可以通过将所有相关的可重定位目标文件打包成为一个单独的文件，这个文件就叫做静态库。在链接时，链接器只拷贝被程序引用的目标模块。减少了可执行文件在磁盘和存储器中的大小。

1. Linux 下的可重定位文件通常是以 `.o` 结尾的文件，也被称为目标文件。这些文件是编译源代码生成的中间文件，包含了编译器将源代码转换成机器代码的结果。

2. Windows 下的可重定位文件通常是以 `.obj` 结尾的文件，也被称为目标文件。这些文件是编译源代码生成的中间文件，包含了编译器将源代码转换成机器代码的结果。

在链接过程中，链接器将这些目标文件组合起来，解析函数和变量之间的引用关系，并生成最终的可执行文件。

[静态链接之与静态库的链接\_静态库链接静态库\_SegmentFault\_的博客-CSDN博客](https://blog.csdn.net/Programmer_acu/article/details/52017234)

```c
// vector.h
extern void addvec(int *, int *, int *, int);
extern void multvec(int *, int *, int *, int);
 
// main.c
#include <stdio.h>
#include "vector.h"
 
int main(void) {
 
    int x[2] = {1, 2};
    int y[2] = {3, 4};
    int z[2] = {0};
 
    addvec(x, y, z, 2);
    printf("%d  %d\n", z[0], z[1]);
    return 0;
}
```
当链接器运行时，链接器解析addvec.o定义的addvec符号被main.o引用，所以它拷贝addvec.o到可执行文件，由于multvec.o的符号没有被引用，所以不会被拷贝到可执行文件，此外还有libc.a的printf.o也被main.o引用，所以会被拷贝到可执行文件。还有许多C运行时系统中的模块。

👉也就是说，被使用的符号才会被链接

### 链接器是如何工作的？
在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件main.o和存档文件libvector.a。在这扫描中，链接器维持一个可重定位目标文件的集合E，一个未解析的符号(即引用了尚未定义的符号)集合U，以及一个在前面输入文件中已定义的符号集合D。

(1)对于命令行上每个输入文件f，链接器会判断f是目标文件还是存档文件。**如果是一个目标文件**，那么链接器把f添加到E，此时E={mian.o}，修改D和U来反映f中的符号定义和引用，U={addvec},并继续下一个输入文件。（**如果是目标文件，就添加当前使用到的未解析的符号**）

(2)如果f是一个**存档文件**，那么**链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号**。在存档文件中定义了addvec符号，用来解析U中对addvec符号的引用，将addvec.o加入到E中，并且链接器修改D和U来反映addvec.o中的符号的定义和引用。对存档文件所有目标文件都反复进行上述过程，直到U和D不在发生变化，也就是找不到一个符号的定义与引用相联系。此时，**任何不包含在E中的成员目标文件都将被丢弃，也就是在main.o未引用的符号**，该符号定义的目标文件，此处为multvec.o，而链接器继续下一个输入文件。

💡在编译器概念中，存档文件（Archive File）指的是一种特定格式的文件，用于存储编译器生成的目标文件（Object File）。存档文件通常具有 `.a` 扩展名，也被称为静态库或库文件。

  存档文件是一种将多个目标文件打包到一个单独文件中的方式。它可以包含编译器生成的多个目标文件，这些目标文件可能是源代码编译后的中间文件或库文件。

  在使用存档文件时，可以使用编译器的静态链接器将存档文件链接到目标程序中。静态链接器会从存档文件中**提取所需的目标文件**，并将其合并到最终的可执行文件中。

(3)如果链接器完成对命令行上文件的扫描，U是非空，那么链接器会输出一个错误并终止，也就是一个未定义的引用。否则，它会合并和E中的目标文件，从而构建输出的可执行文件。

```cobol
kernel@Ubuntu:~/Desktop/StaticLib$ gcc -static  ./libvector.a main.o -o vector
main.o：在函数‘main’中：
main.c:(.text+0x41)：对‘addvec’未定义的引用
collect2: error: ld returned 1 exit status
```

在命令行输入，将libvector.a 和main.o位置调换，就会出现上述错误。因为首先链接器判断f为存档文件，此时U为空集，所以libvector.a中的addvec.o定义的符号无法解析对addvec的引用。因此产生错误。因此最好在链接的时候，将存档文件放到最后。

如果库不是独立的，也就是一个成员引用另一个成员的符号，他们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后。例如fun.c引用了libx.a和liby.a中的函数，而这两个库又调用libz.a的函数，则有：

```crystal
gcc fun.o libx.a liby.a libz.a
```

### 静态库可以静态链接静态库吗？
---
**编译静态库时只有编译过程，没有链接过程**，静态库引用其它库并不会在编译的时候把引用的库函数编译到生成的 lib 中，只是简单的将编译后的中间文件打包，在编译最终的可执行项目（.exe 和 .dll）的时候，需要引用所有的库，进行符号消解。如果你需要封装，使用动态库。

静态库只是一个包含了多个目标文件的存档文件（archive file），并**没有将目标文件中引用的其它库函数包含在其中**。因此，在编译静态库时，**不会**进行符号消解和链接其它库函数。

当我们编译最终的可执行项目（.exe 或 .dll）时，我们需要引用所有的库，并进行符号消解和链接过程。在这个过程中，编译器会根据代码中的库函数引用，去查找并链接相关的库函数。


### chatgpt的一个问题与回答

所以比如一个静态库A依赖静态库B， 在生成静态库A时，添加参数-lB，最终的静态库A中也不会有静态库B的符号，是吗？

对的，静态库 A 在生成过程中添加参数 `-lB` 是无效的，最终的静态库 A 中不会包含静态库 B 的符号。

当编译静态库 A 时，参数 `-lB` 只是告诉编译器在链接阶段需要链接静态库 B，但是并不会将静态库 B 的符号（函数、变量等）包含在最终的静态库 A 中。

静态库 A 只会将自己的目标文件打包成一个单独的文件，不会包含其它库的符号。这意味着，如果你在程序中使用了静态库 A，然后在链接最终的可执行项目时，你需要同时链接静态库 A 和静态库 B，以解决符号消解的问题。

### 那有办法把底层库打包吗？  多个静态库链接成一个静态库？
---
在Linux或MingW上，使用GNU工具链：
```
ar crsT libab.a liba.a libb.a
```

在Windows上，使用MSVC工具链：
```
lib.exe /OUT:libab.lib liba.lib libb.lib
```

| 文件格式   | 归属阶段                                                                                                                                                                                                                    | 文件特点                                                                                                                                                                                                                                                                                                                                                                                                                    | 判断方式                                                                                                             |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| 静态库     | 待链接，可重定向文件.o的集合。                                                                                                                                                                                              | .a文件中的每个目标文件.o均包含 .rel.text, .rel.data等重定向表，并且各个段的VMA和LMA为0x0                                                                                                                                                                                                                                                                                                                                    | objdump -r libxxx.a  <br>objdump -h -j .text libxxx.a                                                                |
| 动态库     | 链接之后生成，已进行相似段合并和地址相对偏移量计算，真正的重定向发生在装载时而非编译时                                                                                                                                      | 不再包含.rel.text和.rel.data等重定向表，VMA和LMA均不为0x0，这个地址是相对于共享库本身而言的偏移量；但会包含.rel.dyn、got、plt等动态库在运行时被重定向所需的重定向表                                                                                                                                                                                                                                                         | objdump -r libxxx.so  <br>objdump -h -j .text libxxx.so  <br>readelf -l libxxx.so  <br>objdump -R ibxxx.so           |
| 可执行文件 | 可能（1）：链接之后生成，已进行相似段合并和地址相对偏移量计算，真正的重定向发生在装载时而非编译时；可能（2）：所有的依赖库均为静态链接，则链接之后生成的可执行文件，已进行相似段合并和地址重定向，VMA的值是绝对虚拟内存地址 | 如果动态链接libc.so，则本质上输出的文件格式为DYN (Shared object file)，基本文件件性质和动态库的so类似，包含.rel.dyn、got、plt等在运行时被重定向所需的重定向表，并且依赖了动态链接器ld-xxx.so；如果是通过-static选项编译生成，并且不依赖任何动态库，则生成的文件格式为EXEC (Executable file)，此时不再包含重定向表 .rel.dyn、.rel.text和.rel.data，VMA和LMA均不为0x0，此时这个地址代表的是被分配到的可用虚拟内存中的绝对地址 | objdump -r xxx_exe  <br>objdump -h -j .text xxx_exe  <br>readelf -l xxx_exe  <br>ldd xxx_exe  <br>objdump -R xxx_exe |
