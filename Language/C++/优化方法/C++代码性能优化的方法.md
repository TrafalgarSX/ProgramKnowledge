备份
[C++代码性能优化的方法（全网最适用） - 知乎](https://zhuanlan.zhihu.com/p/659964355)

本文将总结并详细介绍C++代码性能优化的方法，旨在为C++开发者提供一个全面、实用的性能优化指南。无论你是刚入门的新手，还是有经验的开发者，都能从中找到适用于你的优化技巧。

## 1. 使用const关键字

`const` 是一个修饰符，**可以用来告诉编译器一个变量的值不应该改变。这样可以提高程序的性能**，因为编译器知道这个值是不变的，可以对其进行优化。

同时，使用`const`可以帮助避免一些常见的编程错误。

```text
const int daysInWeek = 7;
```

## 2. 使用inline关键字

`inline` 可以用来提示编译器尝试将函数“内联化”。如果一个函数被内联，那么每次调用这个函数的地方，编译器都会用函数体来替换调用语句，而不是跳转到函数所在的内存位置进行调用。

这样可以减少函数调用的开销，但可能会使得生成的代码体积增大。

```text
inline int add(int a, int b) {
    return a + b;
}
```

## 3. 避免频繁进行内存分配和释放

在C++中，内存分配和释放是比较耗时的操作，尤其是在涉及大量小对象的情况下，频繁的内存操作可能会成为性能瓶颈。

对象池（Object Pooling）是一种在内存中预先分配一块区域，用于存储特定类型的对象的技术。当需要新的对象时，可以直接从对象池中获取，而不是使用new分配新的内存。当对象不再使用时，可以将其返回到对象池，而不是使用delete立即释放内存。这样，可以大大减少内存分配和释放的频率，提高性能。

下面是对象池实现的例子，实际的对象池实现可能会更复杂，需要考虑线程安全、对象的初始化和清理、对象池的大小限制等问题。

```text
#include <list>

template <typename T>
class ObjectPool {
private:
    std::list<T*> objects;

public:
    // 从对象池获取对象
    T* acquire() {
        if (objects.empty()) {
            return new T;
        } else {
            T* obj = objects.front();
            objects.pop_front();
            return obj;
        }
    }

    // 将对象返回到对象池
    void release(T* obj) {
        objects.push_back(obj);
    }

    ~ObjectPool() {
        while (!objects.empty()) {
            delete objects.front();
            objects.pop_front();
        }
    }
};
```

## 4. 某些情况下，使用引用而非指针

在一些特定情况下，使用引用可能会带来微小的性能提升。

例如，如果你的函数接受一个大对象作为参数，那么使用引用（或者指针）而不是按值传递，可以避免复制这个对象，从而提高性能。

此外，如果你的函数需要返回一个大对象，那么返回对象的引用（或者使用 C++11 引入的右值引用和移动语义）也可以避免复制对象。但是这些例子其实是避免了复制，而不是因为使用了引用而非指针。举例：

```text
#include<iostream>

class BigData {
    // 假设这是一个包含大量数据的类
};

void processDataByValue(BigData data) {
    // 如果按值传递，会复制一份 BigData，这可能很消耗资源
}

void processDataByRef(const BigData& data) {
    // 如果通过引用传递，就不需要复制 BigData
}

int main() {
    BigData data;

    // 这将导致 data 的复制
    processDataByValue(data);

    // 这不会导致 data 的复制
    processDataByRef(data);

    return 0;
}
```

## 5. 某些情况下，使用迭代器可能比使用指针更优

如果你需要遍历一个`STL容器`，使用迭代器可以使你的代码更清晰易读，而且不需要关心容器的内部实现。

```text
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用迭代器遍历 vector
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << std::endl;
    }

    return 0;
}
```

## 6. 减少函数的调用次数

减少函数调用次数可以提升程序的性能。函数调用本身是有开销的，特别是当函数被频繁调用时，这个开销可能会显著影响程序的性能。

但是过度优化可能会导致代码变得难以理解和维护。

## 7. 低级代码使用位运算替代算术运算

在过去，位运算符确实比算术运算符在执行速度上更快，因为位运算符直接对二进制位进行操作，而算术运算符需要进行更复杂的计算。

因此，人们经常使用位运算符来优化代码。然而，现代编译器已经足够智能，能够自动优化许多常见的算术运算。

除非你正在编写需要极致性能的低级代码，或者你确定算术运算是性能瓶颈，否则一般不建议手动使用位运算符来替代算术运算符。

## 8. 使用编译器自带的优化选项

现代编译器通常提供了许多优化选项，可以用来提高生成的代码的性能。这些优化包括函数内联、循环展开、死代码消除、常量折叠、指令重排等。

以下是一些常见的`GCC`和`Clang`的优化选项：

-O1：这个选项会启用一些基本的优化，比如移除未使用的代码和变量，简化算术运算等。这个选项提供了一个很好的编译时间和运行时间的平衡。

-O2：这个选项启用了更多的优化，比如代码重排和指令级并行化。这些优化可以使代码运行得更快，但也会使编译时间更长。

-O3：这个选项启用了所有的优化，包括一些会显著增加代码大小的优化，如函数内联和循环展开。这个选项可以使代码运行得最快，但也会使代码的大小增大，而且编译时间也最长。

-Os：这个选项启用了所有不会增加代码大小的优化。这个选项对于需要控制代码大小的系统，比如嵌入式系统，非常有用。

-Ofast：这个选项启用了所有的优化，并且允许编译器违反一些数学准则，如忽略浮点数的NaN和Inf值。这个选项可以使代码运行得最快，但可能会导致数值计算的结果不准确。

-march=native：这个选项让编译器生成针对当前机器的优化代码。这可以提升性能，但生成的代码可能无法在不同的机器上运行。

需要注意的是，编译器优化并不能替代良好的编程实践和算法选择。最有效的优化通常来自于选择正确的数据结构和算法，编写高效的代码，以及避免不必要的工作。编译器优化主要是用来提升已经高效的代码的性能。