### 什么是可哈希对象？
简要的说可哈希的数据类型，即不可变的数据结构(**数字类型（int，float，bool）字符串str、元组tuple、自定义类的对象**)。

对于不可变类型而言，不同的值意味着不同的内存，相同的值存储在相同的内存，如果将我们的不可变对象理解成哈希表中的Key,将内存理解为经过哈希运算的哈希值Value

同理，不可哈希的数据类型，即可变的数据结构 **(字典dict，列表list，集合set)**

对于可变对象而言，比如一个列表，更改列表的值，但是对象的地址本身是不变的，也就是说不同的Key,映射到了相同的Value，这显然是不符合哈希值的特性的，即出现了哈希运算里面的冲突。

#### 本质原因：什么是可哈希性
如果一个对象是可哈希的,那么在它的生存期内必须不可变(而且该对象需要一个哈希函数),而且可以和其他对象比较(需要比较方法).比较值相同的对象一定有相同的哈希值，即一个对象必须要包含有以下几个魔术方法：

- __eq__():用于比较两个对象是否相等
- __cmp__():用于比较两个对象的大小关系，它与__eq__只要有一个就可以了
- __hash__()：实际上就是哈希函数（散列函数），返回经过运算得到的哈希值

### Are tuples hashable in Python?
元组并不总是hashable的，因为元组有可能包含unhashable对象的引用。比如 list dict对象。

**A tuple is only hashable if all of its items are hashable as well.**

### 已经存在list的情况下为什么还要有tuple?
#### 相同点
- 都是序列
- 都可以存储任何数据类型
- 可以通过索引访问，可以切片

#### 列表是可变的
- 增(insert, append,extend)
- 删(pop，remove,clear)
- 改(reverse, sort) 
以上操作不会使id发生变化

#### 为什么要不可变的元组
##### 效率
元组的创建效率比列表高一个数量级。
内部数据一旦创建便无法改变。 如果元组里的元素、元组的大小在创建完成后赋新则id会变化。

取值时，元组和列表的效率差不多。

##### 可哈希
列表是unhashable的

##### 风格
尽管元组看起来类似于列表，但是它们通常用于不同的情况和不同的目的。
- 元组是不可变的，**通常包含异类元素序列，这些元素可通过拆包或索引进行访问。**
- 列表是可变的，**并且它们的元素通常是同质的，可以通过遍历列表来访问。 **

i.e. 列表中存放同类数据， 元组中放异类数据
heterogeneous 异质

##### 元组的用法和其特有的方法
元组可以一次性获取元组中的所有项。
```python
a,b = (1,2)
print('a={},b={}'.format(a,b))
```



