### 易错点
---
JNI 的编写会遇到有很多坑，比如 Java 封装对象和 C++对象的生命周期关系、异步调用逻辑、编译器报错不完善、类型不匹配、JVM 环境不一致、运行线程不一致等等，下面是一些常用的规则。

#### 内存
- 在 C/C++代码中，**使用对象或智能指针去管理内存**，若使用 malloc、calloc 等函数分配内存，然后使用 free 函数释放内存。
- 在 JNI 中，通过 jobject 等 JNI 对象的创建和销毁方法，手动管理 Java 内存。例如，在 JNI 中创建 Java 对象时，需要调用 NewObject 等 JNI 方法创建 Java 对象，**然后在使用完后，需要调用 DeleteLocalRef 等 JNI 方法释放 Java 对象。**

#### 性能
1. **避免频繁创建和销毁 JNI 引用**：创建和销毁 JNI 引用（如 jobject、jclass、jstring 等）的开销比较大，应该尽量避免频繁创建和销毁 JNI 引用。
2. **使用本地数据类型**：JNI 支持本地数据类型（如 jint、jfloat、jboolean 等），这些数据类型与 Java 数据类型相对应，可以直接传递给 Java 代码，避免了数据类型转换的开销。
3. **使用缓存**：如果有一些数据在 JNI 函数中需要重复使用，可以考虑使用缓存，避免重复计算，比如 GetObjectClass、GetMethodID，这些可以保存起来重复使用。
4. **避免频繁切换线程**：JNI 函数会涉及到 Java 线程和本地线程之间的切换，这个过程比较耗时。因此，应该尽量避免频繁切换线程。
5. **避免 Native 侧代码对整体性能造成得侵入**，如 NDK 下 std::vector 分配大数据造成得性能低下，如 RN0.63 版本以前存在这个问题：Make JSStringToSTLString 23x faster (733532e5e9 by @radex)这需要对不同得编译环境差异性有所了解。使用 NDK 编译汇编代码

JNI 本身本身并不能解决性能问题，错误地使用 JNI 反而可能引入新的性能问题，这些问题都是要注意的：

- **问题 1 - 跨越 JNI 边界的调用：** 从 Java 调用 Native 或从 Native 调用 Java 的成本很高，使用 JNI 时要限制跨越 JNI 边界的调用次数；
- **问题 2 - 引用类型数据的回收：** 由于引用类型数据（例如字符串、数组）传递到 JNI 层的只是一个指针，为避免该对象被垃圾回收虚拟机会固定住（pin）对象，在 JNI 方法返回前会阻止其垃圾回收。因此，要尽量缩短 JNI 调用的执行时间，它能够缩短对象被固定的时间（关于引用类型数据的处理，在下文会说到）。

#### 线程安全
1. 当一个线程调用 Java 方法时，**JNI 系统将自动为该线程创建一个 JNIEnv**。一般情况下该上下文只会在Jni函数中被使用，但有时候native代码中需要调用Java层函数，但此时并不在Jni函数中，就需要该上下文。要处理这种情况有两种方式：
	1. 在访问 Java 对象之前，需要手动将当前线程与 JVM 绑定，以便获取 JNIEnv 指针，这个过程就叫做 "Attach"。可以使用 AttachCurrentThread 方法将当前线程附加到 JVM 上，然后就可以使用 JNIEnv 指针来访问 Java 对象了。 在 JNI 中，一般建议每个线程在使用完 JNIEnv 之后，立即 Detach，以释放资源，避免内存泄漏
    2. 在进入Jni函数时，按照线程id缓存每一个线程的JNIEnv, 使用时从缓存中获取。
2. Native 层线程安全需要针对自己得业务去区分是否需要加锁。