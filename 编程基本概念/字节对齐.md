### 什么是字节对齐？
现代计算机中内存空间都是按照byte划分的，**从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，** 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐

#### 内存访问粒度

程序员眼中的内存
![[Pasted image 20230311121414.png]]
CPU眼中的内存
![[Pasted image 20230311121430.png]]

**计算机的处理器并不是以单个字节读取和写入内存的**。 而是以2、4、8、16甚至32字节的块访问内存（提升性能）。 

处理器访问内存的大小就是内存访问粒度

### 对齐的原因和作用
1. 不同硬件平台对存储空间的处理上存在很大的不同。某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。

2. 但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。e.g.
>比如32位的Intel处理器通过总线访问(包括读和写)内存数据。每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。

通过合理的内存对齐可以提高访问效率。**为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。** 

合理利用字节对齐还可以有效节省存储空间。 但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。 因此需要考虑处理器类型。还应该考虑比编译器的类型。
在VC/C++和GNU GCC中都是默认是4字节对齐。

### 对齐的分类和准则
主要介绍x86的结构体对齐和栈内存对齐， 位域本质上为结构体类型。

#### 结构体对齐
在C语言中，结构体是种复合数据类型，其构成元素既可以是基本数据类型(如int、long、float等)的变量，也可以是一些复合数据类型(如数组、结构体、联合等)的数据单元。编译器为结构体的每个成员按照其自然边界(alignment)分配空间。各成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。

字节对齐的问题主要就是针对结构体

##### 示例
简单的例子（32位，x86处理器，GCC编译器）：
```c
struct A{
    int    a;
    char   b;
    short  c;
};
struct B{
    char   b;
    int    a;
    short  c;
};
```

已知32位机器上各数据类型的长度位：char 1byte, short 2byte, int 4byte
long 4byte float 4byte double 8byte

实际结构体占用空间大小：
sizeof(struct A) == 8
sizeof(struct B) == 12

按理说A B大小应该都是7字节。之所以出现上述结果，就是因为编译器要对数据成员在空间上进行对齐。

##### 对齐准则
1. 数据类型自身的对齐值： char类型数据自身对齐值位 1 byte, short型数据位2字节， int/float型位4字节， double型为8字节。
2. **结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。**
3. 指定对齐值： `#progma pack(value)`时的指定对齐值value。
4. 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者。
>i.e. **有效对齐值 = min{自身对齐值， 当前指定的Pack值}。

数据结构成员和其自身的对齐方式：

- 有效对齐值 V 是最终用来决定数据存放地址方式的值。其表示对齐在V上，就是 **该数据的存放起始地址 % V = 0**



