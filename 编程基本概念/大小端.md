### What is Big-Endian(Little-endian)?

- Big-Endian: 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；**这和我们的阅读习惯一致。**

- Little-Endian: 指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。

```
0x12345678 如何存储?
Big-Endian: 低地址存放高位，如下：
   高地址
　　---------------
　　buf[3] (0x78) -- 低位
　　buf[2] (0x56)
　　buf[1] (0x34)
　　buf[0] (0x12) -- 高位
　　---------------
　　低地址
  应用： 网络字节序
　　
Little-Endian: 低地址存放低位，如下：
   高地址
　　---------------
　　buf[3] (0x12) -- 高位
　　buf[2] (0x34)
　　buf[1] (0x56)
　　buf[0] (0x78) -- 低位
　　--------------
低地址
常见的操作系统基本都是小端存储

```

![[Pasted image 20230311033315.png]]

大字节序就是“**高字节存入低地址，低字节存入高地址**”。

这里讲个词源典故：“endian”一词来源于乔纳森·斯威夫特的小说《格列佛游记》。小说中，小人国为水煮蛋该从大的一端(Big-End)剥开还是小的一端(Little-End)剥开而争论，争论的双方分别被称为Big-endians和Little-endians。

- 最高有效位  MSB, Most Significant Byte
- 最低有效位  LSB，Least Significant Byte

#### 网络序
网络传输一般采用大字节序，也称为网络字节序或网络序。IP协议中定义大字节序为网络字节序。

对于可移植的代码来说，将接收的网络数据转换成主机的字节序是必须的，一般会有成对的函数用于把网络数据转换成相应的主机字节序或反之(若主机字节序与网络字节序相同，通常将函数定义为空宏)。

#### 处理器字节序
不同处理器体系的字节序如下所示：
- X86、MOS Technology 6502、Z80、VAX、PDP-11等处理器为Little endian；
- Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC(除V9外)等处理器为Big endian；
- ARM、PowerPC (除PowerPC 970外)、DEC Alpha，SPARC V9，MIPS，PA-RISC and IA64等的字节序是可配置的。

### 大小端和什么有关？
编程语言和大小端没有关系，影响大小端的是 `编译器`/ `CPU`
