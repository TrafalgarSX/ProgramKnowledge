### 线程安全
- 线程私有资源，没有线程安全问题
- 共享资源，线程间以某种秩序使用共享资源也能实现线程安全。

我们说一段代码是线程安全的，而且仅当我们**在多个线程中同时且多次调用的这段代码都能给出正确的结果**，这样的代码我们才说是线程安全代码，Thread Safety，否则就不是线程安全代码，thread-unsafe.。

![[线程安全数据.png]]

**每个线程都有一个私有的栈区**，因此在栈上分配的局部变量就是线程私有的，无论我们怎样使用这些局部变量都不管其它线程屁事。

![[栈区的内容.png]]

##### 线程间共享数据
- 用于动态分配内存的堆区，我们用C/C++中的malloc或者new就是在堆区上申请的内存
- 全局区，这里存放的就是全局变量
- 文件，我们知道线程是共享进程打开的文件
![[共享内容.png]]

**代码区和动态链接库**也是线程共享资源， 但是这两个区域是不能修改的， 也就是这两个区域是只读的， 多个线程使用没有问题。  TODO  动态链接库不可修改是什么意思？

线程使用这些共享资源必须要遵守秩序，这个秩序的核心就是对共享资源的使用不能妨碍到其它线程，无论你使用各种锁也好、信号量也罢，其目的都是在维护公共场所的秩序。

**写出线程安全代码的一大原则就是能用线程私有的资源就用私有资源，线程之间尽最大可能不去使用共享资源。**

如果线程不得已要使用全局资源呢？ 使用全局资源就一定不是线程安全代码吗？

- 如果使用的全局资源只在程序运行时初始化一次，此后所有代码对其使用都是只读的，那么没有问题， 否则对全局变量的修改必须加锁保护。
- 线程局部存储
```c
//我们看到全局变量global_num前加了关键词__thread修饰，这时，func代码就是又是线程安全的了。
__thread int global_num = 100; 

int func() {
  ++global_num;
  return global_num;
}
```

##### 如何实现线程安全
- **不使用任何全局资源**，只使用线程私有资源，这种通常被称为无状态代码
- **线程局部存储**，如果要使用全局资源，是否可以声明为线程局部存储，因为这种变量虽然是全局的，但每个线程都有一个属于自己的副本，对其修改不会影响到其它线程
- **只读**，如果必须使用全局资源，那么全局资源是否可以是只读的，多线程使用只读的全局资源不会有线程安全问题。
- **原子操作**，原子操作是说其在执行过程中是不可能被其它线程打断的，像C++中的std::atomic修饰过的变量，对这类变量的操作无需传统的加锁保护，因为C++会确保在变量的修改过程中不会被打断。我们常说的各种无锁数据结构通常是在这类原子操作的基础上构建的 。
- **同步互斥**，到这里也就确定了你必须要以某种形式使用全局资源，那么在这种情况下公共场所的秩序必须得到维护，那么怎么维护呢？通过同步或者互斥的方式，这是一大类问题，我们将在《深入理解操作系统》系列文章中详细阐述这一问题。

### 信号安全

一般的信号安全指的是在信号处理中，**发生信号异常时调用信号处理函数，都不会造成除了信号处理函数以外的其他功能变化。** 可重入函数就满足了信号安全的特征，所以通常不可重入函数不是信号安全的，就像malloc/free内部有维护全局的共享内存链表，且加锁了，是不可重入函数，所以malloc/free是信号非安全函数。

#### 信号不安全
若此时一个线程中正在调用malloc/free，且刚好在malloc函数加锁之后，被异常信号中断，进入信号处理函数，若在信号处理函数中调用了malloc/free等信号非安全函数，就出现了对同一线程对heap lock连续加了两次锁，则会出现死锁（死锁原因：a线程在信号处理函数中一直在等待主程序解锁，产生阻塞，在信号处理函数中回不到正常程序中，与常见的两个线程产生死锁的理解不同），导致异常。

### 可重入函数

#### 概念
一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函数被重入之后不会产生任何不良后果。

#### 不可重入特征
1. 使用或返回了静态数据结构(全局变量或静态变量)，
2. 标准I/O程序库的一部分(内部会有全局锁，锁也是一种状态)
3. 调用了一个不可重入的函数，例如调用malloc或free (malloc内部维护了全局的链表用来管理分配的内存，这就是状态信息，free也一样)，而且malloc函数虽然本身是线程安全的，但系统调用时存在全局的heap lock（堆内存锁（全局锁），保证堆内存分配时的一致连续性），信号句柄中使用malloc函数时，有可能会发生在主程序调用malloc时，但还未结束，heap lock还未释放，被信号所中断，再次调用malloc函数，就会出现同一线程对heap lock连续两次锁，即会出现死锁 deadlock。

### 三者的区别与联系

1. **一个函数可以是线程安全但不是可重入的**，例如一个函数通过**mutex**来保护了某些共享资源，从线程安全的角度来看，这个函数是线程安全的，但是因为使用了mutex，使得函数是有状态的，因此这个函数不是可重入的。
2. 但可重入函数肯定是线程安全的也是信号安全的
3. 线程安全的并不一定是信号安全的
