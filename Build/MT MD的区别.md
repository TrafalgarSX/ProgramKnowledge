### MT/MD的作用与区别
---
VC项目属性→配置属性→C/C++→代码生成→运行时库 可以采用的方式有：多线程(/MT)、多线程调试(/MTd)、多线程DLL(/MD)、多线程调试DLL(/MDd)。

#### 区别
- /MT：是multithread-static version，是多线程静态版本的意思，项目会使用运行时库的多线程静态版本，编译器会将LIBCMT.lib放入.obj文件中，以便链接器使用LIBCMT.lib解析外部符号;
- /MTd：是定义了_DEBUG和/MT，是/MT类型的debug版本； 
- /MD：是multithread-dll version，是多线程dll版本的意思，项目会使用运行时库的多线程动态dll版本，编译器会将MSVCRT.lib放入.obj文件中，在编译项目时，它会静态链接MSVCRT.lib，但在实际运行过程中，它会链接使用MSVCR90.dll；
- MDd：是定义了_DEBUG和/MD，是/MD类型的debug版本； 
即：

静态运行时库：LIBCMT.lib

动态运行时库：MSVCRT.lib + MSVCR80.DLL

因此，我们在编译时，对应的库一定要配套一致。比如你用CMake生成工程文件时，若CMake是用/MT类型生成的，则它所调用的运行时库为LIBCMT.lib；后面生成工程时，你必须也选择/MT类型，否则你选择/MD类型的话，工程在链接时会调用MSVCRT.lib和MSVCR90.dll，**显然两次调用不同的运行时库，会出现重定义的错误。**

对于多线程MT的程序来说，其连接的是libcmt.lib,该文件属于C语言运行时库，整个lib都会连接到PE文件当中。而多线程MD的程序链接的却是类似msvcpXXX.dll，该文件属于微软运行时库.也就是说如果是多线程MD编译出来的文件运行时都会加载相应版本的运行时库，当如果找不到运行时库就会报错而无法运行，同时如果运行时库不匹配也会出现各种意料之外的崩溃或者程序根本跑不起来等情况。

此时如果两者作为对比就会很明显看到多线程MT编译出来的文件体积要比多线程MD编译出来的大，因为MT是把对应的运行时库直接放到编译出来的PE文件当中，而MD却是运行的时候从第三方dll中获取运行时库，自己本身却不包含。同时另外的区别也很明显，多线程MT编译出来的文件运行时不需要加载第三方dll所以运行效率要比多线程MD稍微高一点点，当然作为用户是完全感觉不到的。
