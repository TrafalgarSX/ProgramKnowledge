### 常见Hash算法
1. MD5（Message Digest Algorithm 5）：
   - 分组长度：512位
   - 结果长度：128位
   - 初始向量IV的长度：无
   - HMAC的密钥长度：无限制

2. SHA-1（Secure Hash Algorithm 1）：
   - 分组长度：512位
   - 结果长度：160位
   - 初始向量IV的长度：无
   - HMAC的密钥长度：无限制

3. SHA-256（Secure Hash Algorithm 256）：
   - 分组长度：512位
   - 结果长度：256位
   - 初始向量IV的长度：无
   - HMAC的密钥长度：无限制

4. SHA-512（Secure Hash Algorithm 512）：
   - 分组长度：1024位
   - 结果长度：512位
   - 初始向量IV的长度：无
   - HMAC的密钥长度：无限制

5. SM3（SM3）：
   - 分组长度：512位
   - 结果长度：256位
   - 初始向量IV的长度：无
   - HMAC的密钥长度：无限制

![[SHA哈希算法.png]]

SHA哈希算法处理步骤(哈希算法基本步骤)：
1. Padding the Message
   **The purpose of this padding is to ensure that the padded message is a multiple of 512 or 1024 bits, depending on the algorithm**. Padding can be inserted before hash computation begins on a message, or at any other time during the hash computation prior to processing the block(s) that will contain the padding.
   
2. Parsing the Message
   The message and its padding must be parsed into N m-bit blocks.
   
3. Setting the Initial Hash Value
   Before hash computation begins for each of the secure hash algorithms, the initial hash value, H(0), must be set. The size and number of words in H(0) depends on the message digest size.

   以下是一些常用的网站，您可以在这些网站上找到关于不同哈希算法的详细信息：

1. NIST (National Institute of Standards and Technology) - 在NIST的网站上，您可以找到关于哈希算法标准的信息和文档。访问链接：https://www.nist.gov/

2. IETF (Internet Engineering Task Force) - IETF是一个开放的国际组织，负责制定互联网标准。您可以在IETF的网站上找到与哈希算法相关的RFC文档。访问链接：https://www.ietf.org/

3. Cryptography Stack Exchange - 这是一个针对密码学和加密技术的问答社区，您可以在这里提问或搜索与哈希算法相关的问题。访问链接：https://crypto.stackexchange.com/

4. OpenSSL - OpenSSL是一个开源的密码学库，它提供了各种哈希算法的实现。您可以在它的官方网站上找到有关哈希算法的详细信息和文档。访问链接：https://www.openssl.org/

请注意，这些网站仅提供了一些常见的资源，如果您需要更具体的信息，可能需要查阅特定的哈希算法标准或相关文档。

### Hash算法有初始向量IV值吗？
---
**大部分哈希算法在计算哈希值时不使用初始向量（IV）。** 初始向量通常在对称加密算法中使用，用于初始化加密算法的状态或密钥扩展。哈希算法是单向函数，它将输入数据映射到固定长度的哈希值，而不涉及密钥或状态的初始化。

然而，**有一些特定的哈希算法（如HMAC）可以使用密钥和初始向量来增加安全性**。HMAC（基于哈希函数的消息认证码）是一种结合密钥和哈希函数的算法，用于提供消息的完整性和认证。在HMAC中，密钥用于对消息进行预处理，并与哈希函数的输出作为输入进行计算，以生成最终的哈希值。

因此，尽管哈希算法本身通常不使用初始向量，但在某些特定的哈希相关算法（如HMAC）中，可以使用初始向量和密钥来提供更强的安全性和认证性能。

有一些与哈希相关的算法可以使用初始向量来增强安全性或提供其他功能。以下是一些常见的与哈希相关的算法，这些算法在某些情况下可能使用初始向量：

1. HMAC（基于哈希函数的消息认证码）：HMAC是一种结合密钥和哈希函数的算法，用于提供消息的完整性和认证。HMAC使用初始向量和密钥对消息进行预处理，并将结果与哈希函数的输出进行计算，以生成最终的哈希值。

2. PBKDF2（密码学安全的密钥派生函数）：PBKDF2是一种密钥派生函数，它使用初始向量和密码学安全的哈希函数（如SHA-1、SHA-256）来生成密钥。初始向量用于增加派生密钥的随机性。

3. bcrypt（一种密码哈希函数）：bcrypt是一种密码哈希函数，它使用初始向量和密钥扩展算法来计算哈希值。初始向量用于增加哈希值的随机性和安全性。

这些算法中的初始向量通常用于增加安全性、提供随机性或防止特定类型的攻击。

### 文档中sha1 sha256等都是有Setting the Initial Hash Value 这一步的, 这不就是iv值吗?
---
#### SHA
SHA-1和SHA-256等哈希算法确实在其算法设计中包含了初始哈希值（也称为初始向量）的设置步骤。

在SHA-1和SHA-256算法中，初始哈希值是一个固定的常量，用于初始化哈希算法的内部状态。这个初始哈希值是预定义的，并且在算法设计中被硬编码。

对于SHA-1算法，初始哈希值是由160位的常量数组组成。对于SHA-256算法，初始哈希值是由256位的常量数组组成。

在实际使用中，您不需要显式地设置或提供初始哈希值。Java中的`MessageDigest`类以及其他哈希库会自动处理这个初始哈希值的设置步骤，并在计算哈希值时使用正确的初始哈希值。

所以，当我们使用Java的`MessageDigest`类调用SHA-1或SHA-256哈希函数时，我们不需要担心初始哈希值的设置，库会自动处理这个步骤。我们只需要提供要计算哈希值的输入数据。

#### SM3 和 MD5
在SM3哈希算法中，确实存在初始哈希值的设置步骤。SM3是中国密码学标准中定义的一种哈希算法，它是一种长度为256位的哈希函数。

在SM3算法中，初始哈希值也被称为初始链接值（IV），它是一个固定的常量，用于初始化算法的内部状态。初始链接值在SM3算法的设计中是预定义的，并且被硬编码在算法中。

初始链接值是一个长度为32个字节的常量，由以下十六进制表示： 

7380166F 4914B2B9 172442D7 DA8A0600 A96F30BC 163138AA E38DEE4D B0FB0E4E


对于MD5哈希算法，它使用了类似的概念，但是没有称为初始哈希值的专门术语。MD5算法使用了一个称为初始状态的固定的内部状态，它是一个长度为128位的常量。初始状态在MD5算法的设计中也是预定义的，并且被硬编码在算法中。

所以，无论是SM3还是MD5，这些哈希算法都有一个固定的初始状态或初始链接值，用于初始化算法的内部状态。这些初始值在算法的设计中是预定义的，并且不需要在使用这些算法时显式地设置或提供。库和实现会自动处理这些初始值的设置。

### HMAC加密方案
---
HMAC 算法是一种基于密钥的报文完整性的验证方法 ，其安全性是建立在 Hash 加密算法基础上的。它要求通信双方共享密钥、约定算法、对报文进行 Hash 运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。 

此方案利用Hash算法，以一个消息M和一个密钥K作为输入，生成其Hash值。

>密钥K是随机选取的（每个用户的密钥K都是随机值），可以采用一种强伪随机发生器，并且密钥需要周期性更新。

当用户注册时，将原始密码进行上述哈希（可加盐）处理后，发给服务器，服务器为该用户生成一个密钥K，将其发给客户端的同时，**对用户密码和密钥K再进行MD5运算**。客户端会将密钥K保存到本地，以后每次登录都对密码经过HMAC加密方案处理后，再将结果发给服务器校验。

上面的流程不难看出，HMAC加密方案 使密码与设备（用户注册时的设备）进行了绑定（其它设备无密钥K）。其它设备想登录此账号时，向服务器请求获取密钥K，服务器会检测用户是否开启了设备锁，如果开启了，就通知授权设备请求授权，授权通过后才会将密钥K发给其它设备。显然，HMAC加密方案相对哈希（可加盐)的处理，更加安全了

#### HAMC算法的定义
HMAC 算法是一种执行“校验和”的算法，它通过对数据进行“校验”来检查数据是否被更改了。

在发送数据以前，HMAC 算法对数据块和双方约定的公钥进行“散列操作”，以生成称为“摘要”的东西，附加在待发送的数据块中。当数据和摘要到达其目的地时，就使用 HMAC 算法来生成另一个校验和，如果两个数字相匹配，那么数据未被做任何篡改。否则，就意味着数据在传输或存储过程中被某些居心叵测的人作了手脚。

💡HMAC密钥的长度与对应哈希算法的分组长度一致

```
HMAC(K，M) = H( (K⊕opad) | H( (K⊕ipad) | M) )
```

- ipad 为 0x36 重复 B（SHA_BLOCKSIZE） 次
- opad 为 0x5c 重复 B（SHA_BLOCKSIZE） 次

HMAC算法的加密步骤

1、在密钥 K 后面添加 0 或者对密钥 K 用 H 进行处理来创建一个字长为 B 的字符串。

(例如，如果 K 的字长是 20 字节，B＝64 字节，则 K 后会加入 44 个零字节 0x00；如果 K 的字长是 120 字节，B＝64 字节，则会用 H 作用于 K 后产生 64 字节的字符串)

2、将上一步生成的 B 字长的字符串与 ipad 做异或运算。

3、将数据流 text（待签名的数据） 填充至第二步的结果字符串中。

4、用 H 作用于第 3 步生成的数据流。

5、将第一步生成的 B 字长字符串与 opad 做异或运算。

6、再将第 4 步的结果填充进第五步的结果中。

7、用 H 作用于第 6 步生成的数据流，输出最终结果 。

![[6968229f53616ed63ef93c5329840946.png]]