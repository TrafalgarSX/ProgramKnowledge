如果你是Web开发者，你很可能需要开发一个用户账户系统。这个系统最重要的方面，就是怎样保护用户的密码。存放帐号的数据库经常成为入侵的目标，**所以你必须做点什么来保护密码，以防网站被攻破时发生危险。最好的办法就是对密码进行加盐哈希**

### 什么是密码哈希
---
哈希算法是一个单向函数。它可以将任何大小的数据转化为定长的“指纹”，并且无法被反向计算。另外，即使数据源只改动了一丁点，哈希的结果也会完全不同（参考上面的例子）。这样的特性使得它非常适合用于保存密码，因为我们需要加密后的密码无法被解密，同时也能保证正确校验每个用户的密码。

### 如何破解哈希
---
1. 字典攻击和暴力攻击
2. 查表法
3. 反向查表法
4. 彩虹表

### 加盐
---
查表法和彩虹表只有在所有密码都以相同方式进行哈希加密时才有效。如果两个用户密码相同，那么他们密码的哈希值也是相同的。我们可以通过“随机化”哈希来阻止这类攻击，于是当相同的密码被哈希两次之后，得到的值就不相同了。

**比如可以在密码中混入一段“随机”的字符串再进行哈希加密，这个被字符串被称作盐值**。如同上面例子所展示的，这使得同一个密码每次都被加密为完全不同的字符串。为了校验密码是否正确，**我们需要储存盐值**。通常和密码哈希值一起存放在账户数据库中，或者直接存为哈希字符串的一部分。

### 错误的方法：短盐值和盐值重复
---
#### 盐值重复
每次哈希加密都使用相同的盐值是很容易犯的一个错误，这个盐值要么被硬编码到程序里，要么只在第一次使用时随机获得。这样加盐的方式是做无用功，因为两个相同的密码依然会得到相同的哈希值。攻击者仍然可以使用反向查表法对每个值进行字典攻击，只需要把盐值应用到每个猜测的密码上再进行哈希即可。如果盐值被硬编码到某个流行的软件里，可以专门为这个软件制作查询表和彩虹表，那么破解它生成的哈希值就变得很简单了。

**用户创建账户或每次修改密码时，都应该重新生成新的盐值进行加密。**

#### 短盐值
如果盐值太短，攻击者可以构造一个查询表包含所有可能的盐值。以只有3个ASCII字符的盐值为例，一共有95x95x95=857,375种可能。这看起来很多，但是如果对于每个盐值查询表只包含1MB最常见的密码，那么总共只需要837GB的储存空间。一个不到100美元的1000GB硬盘就能解决问题。 同样地，用户名也不应该被用作盐值。尽管在一个网站中用户名是唯一的，但是它们是可预测的，并且经常重复用于其他服务中。攻击者可以针对常见用户名构建查询表，然后对用户名盐值哈希发起进攻。

一个好的做法是使用和哈希函数输出的字符串等长的盐值，比如SHA256算法的输出是256bits(32 bytes)，那么盐值也至少应该是32个随机字节。

### Wacky Hash Functions 
---
两次哈希和组合哈希函数

作者不认同这种方式， 觉得效果并不是很优秀

### 恰当使用哈希加密
---
#### 加盐哈希
**盐值应该使用基于加密的伪随机数生成器**（Cryptographically Secure Pseudo-Random Number Generator – CSPRNG）来生成。CSPRNG 和普通的随机数生成器有很大不同，如 C语言中的rand()函数。物如其名，CSPRNG 专门被设计成用于加密，它能提供高度随机和无法预测的随机数。我们显然不希望自己的盐值被猜测到，所以一定要使用 CSPRNG。下面的表格列出了当前主流编程语言中的 CSPRNG 方法：

| **Platform**                      | **CSPRNG**                                                                                                                                                                  |
| --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| PHP                               | [mcrypt_create_iv](http://php.net/manual/en/function.mcrypt-create-iv.php),[openssl_random_pseudo_bytes](http://php.net/manual/en/function.openssl-random-pseudo-bytes.php) |
| Java                              | [java.security.SecureRandom](http://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html)                                                                      |
| Dot NET (C#, VB)                  | [System.Security.Cryptography.RNGCryptoServiceProvider](http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx)                 |
| Ruby                              | [SecureRandom](http://rubydoc.info/stdlib/securerandom/1.9.3/SecureRandom)                                                                                                  |
| Python                            | [os.urandom](http://docs.python.org/library/os.html)                                                                                                                        |
| Perl                              | [Math::Random::Secure](http://search.cpan.org/~mkanat/Math-Random-Secure-0.06/lib/Math/Random/Secure.pm)                                                                    |
| C/C++ (Windows API)               | [CryptGenRandom](http://en.wikipedia.org/wiki/CryptGenRandom)                                                                                                               |
| Any language on GNU/Linux or Unix | Read from [/dev/random](http://en.wikipedia.org/wiki//dev/random) or /dev/urandom                                                                                           |

存储密码的步骤
    使用CSPRNG生成一个长度足够的盐值
    将盐值混入密码，并使用标准的加密哈希函数进行加密，如SHA256
    把哈希值和盐值一起存入数据库中对应此用户的那条记录

校验密码的步骤
    从数据库取出用户的密码哈希值和对应盐值
    将盐值混入用户输入的密码，并且使用同样的哈希函数进行加密
    比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误

#### 在Web程序中，永远在服务器端进行哈希加密
问题在于，从客户端来看，经过哈希的密码逻辑上成为用户真正的密码。为了通过服务器认证，用户只需要发送密码的哈希值即可。如果有坏小子获取了这个哈希值，他甚至可以在不知道用户密码的情况通过认证。更进一步，如果他用某种手段入侵了网站的数据库，那么不需要去猜解任何人的密码，就可以随意使用每个人的帐号登录。

### 让密码更难破解
---
加盐使攻击者无法采用特定的查询表和彩虹表快速破解大量哈希值，但是却不能阻止他们使用字典攻击或暴力攻击。高端的显卡（GPU）和定制的硬件可以每秒进行数十亿次哈希计算，因此这类攻击依然可以很高效。为了降低攻击者的效率，我们可以使用一种叫做**密钥扩展**的技术。

这种技术的思想就是把哈希函数变得很慢，于是即使有着超高性能的GPU或定制硬件，字典攻击和暴力攻击也会慢得让攻击者无法接受。最终的目标是把哈希函数的速度降到足以让攻击者望而却步，但造成的延迟又不至于引起用户的注意。

密钥扩展的实现是依靠一种CPU密集型哈希函数。不要尝试自己发明简单的迭代哈希加密，如果迭代不够多，是可以被高效的硬件快速并行计算出来的，就和普通哈希一样。应该使用标准的算法，比如 [PBKDF2](http://en.wikipedia.org/wiki/PBKDF2)或者 [bcrypt](http://en.wikipedia.org/wiki/Bcrypt)。这里可以找到 [PBKDF2](https://defuse.ca/php-pbkdf2.htm) 在 PHP 上的一种实现。

这类算法使用一个安全因子或迭代次数作为参数，这个值决定了哈希函数会有多慢。对于桌面软件或者手机软件，获取参数最好的办法就是执行一个简短的性能基准测试，找到使哈希函数大约耗费0.5秒的值。这样，你的程序就可以尽可能保证安全，而又不影响到用户体验。

### 无法破解的哈希加密：密钥哈希和密码哈希设备
---
只要攻击者可以检测对一个密码的猜测是否正确，那么他们就可以进行字典攻击或暴力攻击。因此下一步就是向哈希计算中增加一个**密钥**，只有知道这个密钥的人才能校验密码。有两种办法可以实现：将哈希值加密，比如使用AES算法；将密钥包含到哈希字符串中，比如使用密钥哈希算法 [HMAC](http://en.wikipedia.org/wiki/HMAC)。

听起来很简单，做起来就不一样了。这个密钥需要在任何情况下都不被攻击者获取，即使系统因为漏洞被攻破了。如果攻击者获取了进入系统的最高权限，那么不论密钥被储存在哪，他们都可以窃取到。因此密钥需要储存在外部系统中，比如另一个用于密码校验的物理服务器，或者一个关联到服务器的特制硬件，如 [YubiHSM](https://www.yubico.com/YubiHSM)。

[加盐密码哈希：如何正确使用 - Tom CzHen's Blog](https://www.tomczhen.com/2016/10/10/hashing-security/)