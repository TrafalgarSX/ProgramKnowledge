### 非对称加密算法
椭圆曲线加密算法，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全，RSA加密算法也是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。

#### 椭圆曲线公钥密码算法
椭圆曲线公钥密码所基于的曲线性质如下：
- [[有限域]]上椭圆曲线在点加运算下构成有限交换群，且其阶与基域规模相近。
- 类似于有限域乘法群中的乘幂运算，椭圆曲线多倍点运算构成一个单向函数。

在多倍点运算中，**已知多倍点与基点，求解倍数的问题称为椭圆曲线离散对数问题。** 对于一般椭圆曲线的离散对数问题，目前只存在指数级计算复杂度的解决方法。与大数分解问题及有限域上离散对数问题相比，椭圆曲线离散对数问题的求解难度要大得多。

👍因此，在相同安全程度要求下，椭圆曲线密码较其他公钥密码所需的密钥规模要小得多。

针对密码学应用上的椭圆曲线是在[[有限域]](不是实数域)的平面曲线，其方程式如下：
$$y^{2}=x^{3}+a x+b$$
有一个特别的无穷远点（标识为∞）。坐标会选定为特定的有限域，其**特征**不等于2或是3，也有可能是更复杂的曲线方程。

由椭圆曲线产生的集合是[[群#阿贝尔群]]，以无穷远点为单位元。
![[ECC原理.png]]

##### 椭圆曲线的加法
过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C
![[椭圆曲线的加法.png]]

##### 椭圆曲线的二倍运算
上述方法无法解释A + A，即两点重合的情况，因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。
![[椭圆曲线的二倍运算.png]]

##### 同余运算
同余就是有相同的余数，两个整数 a、 b，若它们除以正整数 m所得的余数相等，则称 a， b对于模m同余。$$a\equiv b(m o d m)$$
##### 有限域
**椭圆曲线是连续的，并不适合用于加密**；所以必须把椭圆曲线变成**离散的点**，要把椭圆曲线定义在有限域上。而椭圆曲线密码所使用的椭圆曲线是定义在有限域内，有限域最常见的例子是有限域GF(p)，指给定某质数p，由0,1,2...p-1共p个元素组成的整数集合中加法、二倍运算。例如GF(233)就是：
$$y^{2}=(x^{3}+7)(m o d223)$$
##### 乘法逆元
TODO 

#### 椭圆曲线加解密算法原理
设私钥、公钥分别为d、Q，即Q = dG，其中G为基点，椭圆曲线上的已知G和dG，求d是非常困难的，也就是说已知公钥和基点，想要算出私钥是非常困难的。
>基点是椭圆曲线上选择的一个点，这个点能够保证满足nG=∞的最小正整数n足够大（也就是阶足够大）（1<私钥<n，大于n的私钥a必能在`[1,n)`中找到对应的私钥b使得aG=bG，换句话说也就是有足够多的私钥）

公钥加密：选择随机数r，将消息M生成密文C，该密文是一个点对，C = {rG, M+rQ}，其中Q为公钥。
私钥解密：M + rQ - d(rG) = M + r(dG) - d(rG) = M，其中d、Q分别为私钥、公钥。

#### 椭圆曲线签名算法原理
椭圆曲线签名算法(ECDSA)。设私钥、公钥分别为d、Q，即Q = dG，其中G为基点。

私钥签名：

- 选择随机数r，计算点rG(x, y)。
- 根据随机数r、消息M的哈希h、私钥d，计算s = (h + dx)/r。　　
- 将消息M、和签名{rG, s}发给接收方。

公钥验证签名：　　

- 接收方收到消息M、以及签名{rG=(x,y), s}。　　
- 根据消息求哈希h。　　
- 使用发送方公钥Q计算：hG/s + xQ/s，并与rG比较，如相等即验签成功。

原理：hG/s + xQ/s = hG/s + x(dG)/s = (h+xd)G/s = r(h+xd)G / (h+dx) = rG

#### 签名过程
假设要签名的消息是一个字符串：“Hello World!”。DSA签名的第一个步骤是对待签名的消息生成一个消息摘要，不同的签名算法使用不同的消息摘要算法，而ECDSA256使用SHA256生成256比特的摘要。

摘要生成结束后，应用签名算法对摘要进行签名：

- 产生一个随机数k
- 利用随机数k，计算出两个大数r和s。将r和s拼在一起就构成了对消息摘要的签名。

这里需要注意的是，**因为随机数k的存在，对于同一条消息，使用同一个算法，产生的签名是不一样的。** 从函数的角度来理解，签名函数对同样的输入会产生不同的输出。因为函数内部会将随机值混入签名的过程。

#### 验证过程
关于验证过程，这里不讨论它的算法细节。从宏观上看，消息的接收方从签名中分离出r和s，然后利用公开的密钥信息和s计算出r。如果计算出的r和接收到的r值相同，则表示验证成功，否则，表示验证失败。

