### 应该在Git中存储哪些类型的文件
---
#### 源代码非依赖项
团队使用编辑器和工具来创建和更新文件时，应将这些文件放入 Git 中，以便团队可以享受 Git 工作流的优势。 **不要将 DLL、库文件等其他类型的文件，以及并非由团队创建但代码依赖的其他依赖项提交到存储库中**。 通过包管理将这些文件传递到系统。

#### 不要提交输出
不要提交生成和测试中的**二进制文件、日志、跟踪输出或诊断数据**。 这些是代码的输出，而不是源代码本身。 通过工作项跟踪工具或通过团队文件共享与团队共享日志和跟踪信息。

#### 在Git中存储不经常更新的小型二进制源
**不经常更新的二进制源文件提交的版本相对较少**，如果文件较小，就不会占用太多空间。 Web 图像、图标和其他较小的艺术资产都属于这一类别。 最好将这些文件与源的其余部分一起存储在 Git 中，以便团队可以使用一致的工作流。

⚠️如果经常更新，即使是小型二进制文件也会引发问题。 对 100 KB 的二进制文件进行 100 次更改所用的存储空间与对 1 MB 的二进制文件进行 10 次更改所用的存储空间一样多，并且由于更新频率，与大型二进制文件相比，较小的二进制文件会更频繁地降低分支性能。

#### 不要提交经常更新的大型二进制资产
Git 管理文件的一个主要版本，然后**仅存储与该版本的差异**，这一过程称为“增量存储”。 通过增量存储和文件压缩，Git 可将整个代码历史记录存储在本地存储库中。 

不同版本的大型二进制文件通常完全不同，并且通常已经过压缩，这使得 Git 难以管理这些文件，因为版本之间的差异非常大。 **Git 必须存储每个文件版本的全部内容，并且很难通过增量存储和压缩来节省空间**。 

存储这些文件的完整文件版本会导致存储库大小随时间的推移而增加，**从而降低分支性能、增加克隆时间并扩大存储需求。**

#### 使用大型二进制源文件的策略
- 不要提交压缩的数据存档。 最好解压缩文件并提交可区分的源，让 Git 处理存储库中的数据压缩
   ❗像 jar 包这种用 git 管理，别人下载下来就可能是没法用的， 之前出现过这样的情况。
   
- 避免提交已编译的代码和其他二进制依赖项。 提交源并生成依赖项，或使用包管理解决方案对这些文件进行版本控制并将其提供给系统。
  ❗避免提交.obj 或 .o 或 .class文件， 动态库，静态库最好也不要提交， 除非库文件不会频繁更新。
  
- 以可区分的纯文本格式（例如 JSON）存储配置和其他结构化数据。
  
#### 使用Git大型文件存储 LFS
源文件的各版本之间差异较大且更新频繁时，可以使用 [Git LFS](https://git-lfs.github.com/) 来管理这些文件类型。 Git LFS 是 Git 的扩展，它通过提交将**描述大文件的数据提交到存储库**，并将二进制文件内容**存储到单独的远程存储中**。 当你在存储库中克隆和切换分支时，Git LFS 会从该远程存储下载正确的版本。 本地开发工具将以透明方式处理文件，就如同这些文件是直接提交到存储库一样。

在采用 Git LFS 之前，需要考虑到它的一些缺点：

1. 团队使用的每个 Git 客户端都必须安装 Git LFS 客户端并了解其跟踪配置。
2. 如果未正确安装并配置 Git LFS 客户端，则在克隆存储库时将看不到通过 Git LFS 提交的二进制文件。 Git 将下载描述大文件（由 Git LFS 提交到存储库）的数据，而不是实际的二进制文件本身。 在未安装 Git LFS 客户端的情况下提交大二进制文件会将二进制文件推送到存储库。
3. Git 无法合并两个不同二进制文件版本中的更改，即使这两个版本具有共同的父级。 如果两个人同时处理同一个文件，他们必须一起协调他们的更改，以避免覆盖对方的工作。 Git LFS 可提供文件锁定来帮助处理文件。 在开始工作之前，用户仍然必须注意拉取二进制文件资产的最新副本。
4. Azure Repos 目前不支持在包含 Git LFS 跟踪文件的存储库中使用 SSH。
5. 如果用户通过 Web 界面将二进制文件拖放到为 Git LFS 配置的存储库中，则二进制文件将提交到存储库，而不是通过 Git LFS 客户端提交的指针。
6. 文件大小限制为 50 GB。
7. 一个文件的上传时间限制为 1 小时。

