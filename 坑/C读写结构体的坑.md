### C中将结构体写入文件及读取
fopen中 "w"  "wb"的区别：
- "w"是以文本的形式进行写入
- "wb"是以二进制模式写入

如何准确理解呢？  不都是可以从文件中一个字节一个字节读取写入吗？

```c
int write()
{
	char *err_buf = NULL;
	FILE *fp = NULL;
	rect my_record;

	errno = fopen_s(&fp, "input.txt", "wb");
	if (0x00 != errno)
	{
		/* size_t errmsglen = strerrorlen_s(errno) + 1; */
		size_t errmsglen = 100;
		err_buf = calloc(1, errmsglen);
		strerror_s(err_buf, errmsglen, errno);
		printf("%s\n", err_buf);
	}

	for (int i = 0x00; i < 10; i++) {
		my_record.x = 10;
		my_record.y = 11;
		my_record.w = i;
		my_record.h = i;
		fwrite(&my_record, sizeof(rect), 1, fp);
	}

	fclose(fp);
	return 0;
	}
```

此时向文件中写入结构体时，文件内容为（16进制）:
```text
00000000: 0a00 0000 0b00 0000 0000 0000 0000 0000  ................
00000010: 0a00 0000 0b00 0000 0100 0000 0100 0000  ................
00000020: 0a00 0000 0b00 0000 0200 0000 0200 0000  ................
00000030: 0a00 0000 0b00 0000 0300 0000 0300 0000  ................
00000040: 0a00 0000 0b00 0000 0400 0000 0400 0000  ................
00000050: 0a00 0000 0b00 0000 0500 0000 0500 0000  ................
00000060: 0a00 0000 0b00 0000 0600 0000 0600 0000  ................
00000070: 0a00 0000 0b00 0000 0700 0000 0700 0000  ................
00000080: 0a00 0000 0b00 0000 0800 0000 0800 0000  ................
00000090: 0a00 0000 0b00 0000 0900 0000 0900 0000  ................
000000a0: 0a                                       .
```

0a没有前缀 0d

0x0d  `\t` carrige return 打字头归位的动作
0x0a  `\n` new line 指打字机上卷一行的动作

Windows 在行尾使用CRLF 0x0d0x0a
UNIX 只使用 LF 0x0a

如果fopen用 "w", 此时向文件中写入结构体的文件内容为（16进制）:
```c
00000000: 0d0a 0000 000b 0000 0000 0000 0000 0000  ................
00000010: 000d 0a00 0000 0b00 0000 0100 0000 0100  ................
00000020: 0000 0d0a 0000 000b 0000 0002 0000 0002  ................
00000030: 0000 000d 0a00 0000 0b00 0000 0300 0000  ................
00000040: 0300 0000 0d0a 0000 000b 0000 0004 0000  ................
00000050: 0004 0000 000d 0a00 0000 0b00 0000 0500  ................
00000060: 0000 0500 0000 0d0a 0000 000b 0000 0006  ................
00000070: 0000 0006 0000 000d 0a00 0000 0b00 0000  ................
00000080: 0700 0000 0700 0000 0d0a 0000 000b 0000  ................
00000090: 0008 0000 0008 0000 000d 0a00 0000 0b00  ................
000000a0: 0000 0900 0000 0900 0000 0d0a            ............
```

为什么 0d0a 0000   和  000d 0a00交替着来？

这只是一个测试：
>但是这样用内存映像写出的数据文件却是不能够移植的，尤其是当结构中包含浮点成员或指针的时候。结构的内存布局跟机器和编译器都有关。
>不同的编译器可能使用不同数量的填充位，不同机器上基本类型的大小和字节顺序也不尽相同。因此，作为内存映像写出的结构在别的机器上（甚至是被别的编译器编译之后）不一定能被读回来。